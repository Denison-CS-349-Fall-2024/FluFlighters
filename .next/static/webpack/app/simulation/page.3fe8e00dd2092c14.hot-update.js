"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/simulation/page",{

/***/ "(app-pages-browser)/./src/app/simulation/page.tsx":
/*!*************************************!*\
  !*** ./src/app/simulation/page.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Simulation; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_SimulationControls__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/SimulationControls */ \"(app-pages-browser)/./src/app/simulation/components/SimulationControls.tsx\");\n/* harmony import */ var _components_PopulationCanvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/PopulationCanvas */ \"(app-pages-browser)/./src/app/simulation/components/PopulationCanvas.tsx\");\n/* harmony import */ var _components_StatusChart__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/StatusChart */ \"(app-pages-browser)/./src/app/simulation/components/StatusChart.tsx\");\n/* harmony import */ var _components_SimulationControlsPopover__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/SimulationControlsPopover */ \"(app-pages-browser)/./src/app/simulation/components/SimulationControlsPopover.tsx\");\n/* harmony import */ var _components_Person__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/Person */ \"(app-pages-browser)/./src/app/simulation/components/Person.ts\");\n// \"use client\";\n// import { useSearchParams } from \"next/navigation\";\n// import dynamic from \"next/dynamic\";\n// import { useEffect, useRef, useState } from \"react\";\n// import { Line } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   LineElement,\n//   CategoryScale,\n//   LinearScale,\n//   PointElement,\n// } from \"chart.js\";\n// // Dynamically load react-p5 since p5.js relies on browser-specific features\n// const Sketch = dynamic(() => import(\"react-p5\").then((mod) => mod.default), {\n//   ssr: false,\n// });\n// // Register Chart.js components\n// ChartJS.register(LineElement, CategoryScale, LinearScale, PointElement);\n// // Define chart data type\n// type ChartData = {\n//   labels: number[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     borderColor: string;\n//     fill: boolean;\n//   }[];\n// };\n// export default function Simulation() {\n//   const searchParams = useSearchParams();\n//   const vaccineEfficacy = parseFloat(\n//     searchParams.get(\"vaccineEfficacy\") || \"0.8\"\n//   );\n//   const populationVaccinated = parseFloat(\n//     searchParams.get(\"populationVaccinated\") || \"0.7\"\n//   );\n//   const infectionProbability = parseFloat(\n//     searchParams.get(\"infectionProbability\") || \"0.5\"\n//   );\n//   const vaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"vaccinatedRecoveryRate\") || \"0.5\"\n//   );\n//   const unvaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"unvaccinatedRecoveryRate\") || \"0.1\"\n//   );\n//   const peakInfectionDay = parseInt(\n//     searchParams.get(\"peakInfectionDay\") || \"5\"\n//   );\n//   const totalDays = parseInt(searchParams.get(\"totalDays\") || \"30\");\n//   const populationSize = parseInt(searchParams.get(\"populationSize\") || \"250\");\n//   // Population array managed outside of React state for performance\n//   const [people, setPeople] = useState<Person[]>([]);\n//   //const populationSize = 100;\n//   const p5Instance = useRef<any>(null); // Reference to p5.js instance\n//   // Simulation speed control\n//   const [speed, setSpeed] = useState(1); // 1x speed by default\n//   // Chart data\n//   const [chartData, setChartData] = useState<ChartData>({\n//     labels: [], // Frame count (or time steps)\n//     datasets: [\n//       {\n//         label: \"Healthy\",\n//         data: [],\n//         borderColor: \"blue\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Infected\",\n//         data: [],\n//         borderColor: \"red\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Recovered\",\n//         data: [],\n//         borderColor: \"green\",\n//         fill: false,\n//       },\n//     ],\n//   });\n//   const frameCount = useRef(0); // Keep track of the simulation frames\n//   // Person object representing each individual in the population\n//   class Person {\n//     x: number;\n//     y: number;\n//     status: string; // 'healthy', 'infected', 'recovered'\n//     vaccinated: boolean;\n//     constructor(x: number, y: number, vaccinated: boolean, status = \"healthy\") {\n//       this.x = x;\n//       this.y = y;\n//       this.vaccinated = vaccinated;\n//       this.status = status;\n//     }\n//     // Determine if a person can get infected\n//     tryToInfect(p5: any, infectionRadius: number) {\n//       if (this.status === \"healthy\") {\n//         for (let other of people) {\n//           if (other.status === \"infected\") {\n//             // Check if this person is within infection radius\n//             let d = p5.dist(this.x, this.y, other.x, other.y);\n//             if (d < infectionRadius) {\n//               // Check vaccination status and infection probability\n//               if (!this.vaccinated || Math.random() > vaccineEfficacy) {\n//                 // Random chance of infection\n//                 if (Math.random() < infectionProbability) {\n//                   this.status = \"infected\"; // This person gets infected\n//                 }\n//               }\n//             }\n//           }\n//         }\n//       }\n//     }\n//     move(p5: any) {\n//       this.x += p5.random(-5, 5); // Increased movement\n//       this.y += p5.random(-5, 5);\n//       this.x = p5.constrain(this.x, 0, p5.width);\n//       this.y = p5.constrain(this.y, 0, p5.height);\n//     }\n//     show(p5: any) {\n//       if (this.status === \"healthy\") {\n//         p5.fill(100, 200, 255); // blue for healthy\n//       } else if (this.status === \"infected\") {\n//         p5.fill(255, 100, 100); // red for infected\n//       } else if (this.status === \"recovered\") {\n//         p5.fill(0, 255, 0); // green for recovered\n//       }\n//       p5.ellipse(this.x, this.y, 20, 20);\n//     }\n//     // recover() {\n//     //   if (this.status === \"infected\" && Math.random() < 0.01) {\n//     //     this.status = \"recovered\";\n//     //   }\n//     // }\n//     // new recover function needed\n//     recover() {\n//       if (this.status === \"infected\") {\n//         const recoveryChance = this.vaccinated\n//           ? vaccinatedRecoveryRate\n//           : unvaccinatedRecoveryRate;\n//         if (Math.random() < recoveryChance) {\n//           this.status = \"recovered\";\n//         }\n//       }\n//     }\n//   }\n//   // Initialize population once in useEffect\n//   useEffect(() => {\n//     if (people.length === 0) {\n//       const newPeople: Person[] = [];\n//       for (let i = 0; i < populationSize; i++) {\n//         let x = Math.random() * 800;\n//         let y = Math.random() * 600;\n//         let vaccinated = Math.random() < populationVaccinated;\n//         newPeople.push(new Person(x, y, vaccinated));\n//       }\n//       for (let i = 0; i < 50; i++) {\n//         newPeople[i].status = \"infected\"; // setting to infected from start\n//       }\n//       setPeople(newPeople);\n//     }\n//   }, []); // Empty dependency array ensures people are initialized only once\n//   // Function to update chart data\n//   const updateChartData = (\n//     healthy: number,\n//     infected: number,\n//     recovered: number,\n//     frame: number\n//   ) => {\n//     setChartData((prevData) => ({\n//       labels: [...prevData.labels, frame], // Append the new frame count\n//       datasets: [\n//         {\n//           ...prevData.datasets[0],\n//           data: [...prevData.datasets[0].data, healthy], // Append the new healthy count\n//         },\n//         {\n//           ...prevData.datasets[1],\n//           data: [...prevData.datasets[1].data, infected], // Append the new infected count\n//         },\n//         {\n//           ...prevData.datasets[2],\n//           data: [...prevData.datasets[2].data, recovered], // Append the new recovered count\n//         },\n//       ],\n//     }));\n//   };\n//   // p5.js setup and draw functions\n//   const setup = (p5: any, canvasParentRef: Element) => {\n//     p5.createCanvas(800, 600).parent(canvasParentRef);\n//     p5Instance.current = p5; // Save p5.js instance for future reference\n//     p5.frameRate(30); // Set default frame rate\n//   };\n//   const draw = (p5: any) => {\n//     p5.background(255);\n//     let healthyCount = 0;\n//     let infectedCount = 0;\n//     let recoveredCount = 0;\n//     // Render and update each person\n//     people.forEach((person) => {\n//       person.move(p5);\n//       person.show(p5);\n//       person.tryToInfect(p5, 50); // Infection radius is 50 pixels\n//       person.recover();\n//       // Count people by their status\n//       if (person.status === \"healthy\") healthyCount++;\n//       if (person.status === \"infected\") infectedCount++;\n//       if (person.status === \"recovered\") recoveredCount++;\n//     });\n//     if (frameCount.current > totalDays * 30) {\n//       p5.noLoop();\n//     }\n//     // Update the chart every frame\n//     frameCount.current++;\n//     updateChartData(\n//       healthyCount,\n//       infectedCount,\n//       recoveredCount,\n//       frameCount.current\n//     );\n//   };\n//   // Handle speed changes using p5's frameRate()\n//   const handleSpeedChange = () => {\n//     if (speed === 1) {\n//       setSpeed(2); // Speed up to 2x\n//       p5Instance.current.frameRate(60); // Double the frame rate for 2x speed\n//     } else if (speed === 2) {\n//       setSpeed(4); // Speed up to 4x\n//       p5Instance.current.frameRate(120); // Quadruple the frame rate for 4x speed\n//     } else {\n//       setSpeed(1); // Reset to 1x speed\n//       p5Instance.current.frameRate(30); // Default frame rate\n//     }\n//   };\n//   return (\n//     <div style={{ display: \"flex\", gap: \"20px\" }}>\n//       {/* Left: Simulation */}\n//       <div>\n//         <h2>Flu Simulation</h2>\n//         <p>Vaccine Efficacy: {Math.round(vaccineEfficacy * 100)}%</p>\n//         <p>Population Vaccinated: {Math.round(populationVaccinated * 100)}%</p>\n//         <p>Infection Probability: {Math.round(infectionProbability * 100)}%</p>\n//         <p>\n//           {\" \"}\n//           Vaccinated Recovery Rate: {Math.round(vaccinatedRecoveryRate * 100)}%\n//         </p>\n//         <p>\n//           Unvaccinated Recovery Rate:{\" \"}\n//           {Math.round(unvaccinatedRecoveryRate * 100)}%\n//         </p>\n//         <p>Peak Infection Day: {peakInfectionDay}</p>\n//         <p>Total Days: {totalDays}</p>\n//         <p>Population Size: {populationSize}</p>\n//         <button onClick={handleSpeedChange}>\n//           {speed === 1\n//             ? \"Speed Up (2x)\"\n//             : speed === 2\n//             ? \"Speed Up (4x)\"\n//             : \"Reset Speed (1x)\"}\n//         </button>\n//         <Sketch setup={setup} draw={draw} />\n//       </div>\n//       {/* Right: Line Graph */}\n//       <div style={{ width: \"400px\" }}>\n//         <h3>Status Over Time</h3>\n//         <Line data={chartData} />\n//       </div>\n//     </div>\n//   );\n// }\n//---------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------\n// \"use client\";\n// import { useSearchParams } from \"next/navigation\";\n// import dynamic from \"next/dynamic\";\n// import { useEffect, useRef, useState } from \"react\";\n// import { Line } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   LineElement,\n//   CategoryScale,\n//   LinearScale,\n//   PointElement,\n// } from \"chart.js\";\n// import Modal from 'react-modal';\n// // Dynamically load react-p5 since p5.js relies on browser-specific features\n// const Sketch = dynamic(() => import(\"react-p5\").then((mod) => mod.default), {\n//   ssr: false,\n// });\n// // Register Chart.js components\n// ChartJS.register(LineElement, CategoryScale, LinearScale, PointElement);\n// // Define chart data type\n// type ChartData = {\n//   labels: number[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     borderColor: string;\n//     fill: boolean;\n//     borderDash?: number[];\n//   }[];\n// };\n// export default function Simulation() {\n//   const [showModal, setShowModal] = useState(false);\n//   const [graphs, setGraphs] = useState([]);\n//   const searchParams = useSearchParams();\n//   const addNewGraph = (newParams)=> {\n//     const newGraphData = runSimulation(newParams);\n//     setGraphs([...graphs, newGraphData]);\n//     setShowModal(false);\n//   }\n//   // Extract parameters from URL\n//   const vaccineEfficacy = parseFloat(\n//     searchParams.get(\"vaccineEfficacy\") || \"0.8\"\n//   );\n//   const populationVaccinated = parseFloat(\n//     searchParams.get(\"populationVaccinated\") || \"0.7\"\n//   );\n//   const infectionProbability = parseFloat(\n//     searchParams.get(\"infectionProbability\") || \"0.5\"\n//   );\n//   const vaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"vaccinatedRecoveryRate\") || \"0.5\"\n//   );\n//   const unvaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"unvaccinatedRecoveryRate\") || \"0.1\"\n//   );\n//   const peakInfectionDay = parseInt(\n//     searchParams.get(\"peakInfectionDay\") || \"5\"\n//   );\n//   const totalDays = parseInt(searchParams.get(\"totalDays\") || \"30\");\n//   const populationSize = parseInt(searchParams.get(\"populationSize\") || \"100\");\n//   // State for simulation data\n//   const [days, setDays] = useState<number[]>([]);\n//   const [susceptiblePopulation, setSusceptiblePopulation] = useState<number[]>(\n//     []\n//   );\n//   const [infectedPopulation, setInfectedPopulation] = useState<number[]>([]);\n//   const [recoveredVaccinated, setRecoveredVaccinated] = useState<number[]>([]);\n//   const [recoveredUnvaccinated, setRecoveredUnvaccinated] = useState<number[]>(\n//     []\n//   );\n//   const [totalRecoveredPopulation, setTotalRecoveredPopulation] = useState<\n//     number[]\n//   >([]);\n//   const [speed, setSpeed] = useState(1); // 1x speed by default\n//   const p5Instance = useRef<any>(null); // Reference to p5.js instance\n//   // Chart data\n//   const [chartData, setChartData] = useState<ChartData>({\n//     labels: [], // Frame count (or time steps)\n//     datasets: [\n//       {\n//         label: \"Susceptible\",\n//         data: [],\n//         borderColor: \"orange\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Infected\",\n//         data: [],\n//         borderColor: \"red\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Total Recovered\",\n//         data: [],\n//         borderColor: \"green\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Recovered Vaccinated\",\n//         data: [],\n//         borderColor: \"blue\",\n//         borderDash: [5, 5],\n//         fill: false,\n//       },\n//       {\n//         label: \"Recovered Unvaccinated\",\n//         data: [],\n//         borderColor: \"purple\",\n//         borderDash: [5, 5],\n//         fill: false,\n//       },\n//     ],\n//   });\n//   // Initialize and calculate flu model data\n//   useEffect(() => {\n//     const daysArray = Array.from(\n//       { length: 100 },\n//       (_, i) => (i / 100) * totalDays\n//     );\n//     setDays(daysArray);\n//     const vaccinatedPopulation = populationSize * populationVaccinated;\n//     const unvaccinatedPopulation = populationSize * (1 - populationVaccinated);\n//     // Calculate recovered population\n//     const recoveredVaccinatedArray = daysArray.map(\n//       (day) =>\n//         (1 / (1 + Math.exp(-vaccinatedRecoveryRate * (day - totalDays / 2)))) *\n//         vaccinatedPopulation\n//     );\n//     const recoveredUnvaccinatedArray = daysArray.map(\n//       (day) =>\n//         (1 /\n//           (1 + Math.exp(-unvaccinatedRecoveryRate * (day - totalDays / 2)))) *\n//         unvaccinatedPopulation\n//     );\n//     const infectedArray = daysArray.map(\n//       (day) =>\n//         Math.exp(-infectionProbability * (day - peakInfectionDay) ** 2) *\n//         populationSize\n//     );\n//     const recoveredArray = recoveredVaccinatedArray.map(\n//       (rv, i) => rv + recoveredUnvaccinatedArray[i]\n//     );\n//     const susceptibleArray = daysArray.map((_, i) => {\n//       const susceptibleValue =\n//         populationSize - (infectedArray[i] + recoveredArray[i]);\n//       return Math.max(susceptibleValue, 0); // Ensure no negative values\n//     });\n//     // Set calculated state variables\n//     setSusceptiblePopulation(susceptibleArray);\n//     setInfectedPopulation(infectedArray);\n//     setRecoveredVaccinated(recoveredVaccinatedArray);\n//     setRecoveredUnvaccinated(recoveredUnvaccinatedArray);\n//     setTotalRecoveredPopulation(recoveredArray);\n//   }, [\n//     infectionProbability,\n//     vaccinatedRecoveryRate,\n//     unvaccinatedRecoveryRate,\n//     populationVaccinated,\n//     peakInfectionDay,\n//     totalDays,\n//     populationSize,\n//   ]);\n//   // Update chart data when state changes\n//   useEffect(() => {\n//     setChartData({\n//       labels: days,\n//       datasets: [\n//         {\n//           label: \"Susceptible\",\n//           data: susceptiblePopulation,\n//           borderColor: \"orange\",\n//           fill: false,\n//         },\n//         {\n//           label: \"Infected\",\n//           data: infectedPopulation,\n//           borderColor: \"red\",\n//           fill: false,\n//         },\n//         {\n//           label: \"Total Recovered\",\n//           data: totalRecoveredPopulation,\n//           borderColor: \"green\",\n//           fill: false,\n//         },\n//         {\n//           label: \"Recovered Vaccinated\",\n//           data: recoveredVaccinated,\n//           borderColor: \"blue\",\n//           borderDash: [5, 5],\n//           fill: false,\n//         },\n//         {\n//           label: \"Recovered Unvaccinated\",\n//           data: recoveredUnvaccinated,\n//           borderColor: \"purple\",\n//           borderDash: [5, 5],\n//           fill: false,\n//         },\n//       ],\n//     });\n//   }, [\n//     days,\n//     susceptiblePopulation,\n//     infectedPopulation,\n//     totalRecoveredPopulation,\n//     recoveredVaccinated,\n//     recoveredUnvaccinated,\n//   ]);\n//   // p5.js setup and draw functions\n//   const setup = (p5: any, canvasParentRef: Element) => {\n//     p5.createCanvas(800, 600).parent(canvasParentRef);\n//     p5Instance.current = p5;\n//     p5.frameRate(30);\n//   };\n//   const draw = (p5: any) => {\n//     p5.background(255);\n//   };\n//   // Handle speed changes using p5's frameRate()\n//   const handleSpeedChange = () => {\n//     if (speed === 1) {\n//       setSpeed(2);\n//       p5Instance.current.frameRate(60);\n//     } else if (speed === 2) {\n//       setSpeed(4);\n//       p5Instance.current.frameRate(120);\n//     } else {\n//       setSpeed(1);\n//       p5Instance.current.frameRate(30);\n//     }\n//   };\n//   return (\n//     <div style={{ display: \"flex\", gap: \"20px\" }}>\n//       {/* Left: Simulation */}\n//       <div>\n//         <h2>Flu Simulation</h2>\n//         <p>Vaccine Efficacy: {Math.round(vaccineEfficacy * 100)}%</p>\n//         <p>Population Vaccinated: {Math.round(populationVaccinated * 100)}%</p>\n//         <p>Infection Probability: {Math.round(infectionProbability * 100)}%</p>\n//         <p>\n//           Vaccinated Recovery Rate: {Math.round(vaccinatedRecoveryRate * 100)}%\n//         </p>\n//         <p>\n//           Unvaccinated Recovery Rate:{\" \"}\n//           {Math.round(unvaccinatedRecoveryRate * 100)}%\n//         </p>\n//         <p>Peak Infection Day: {peakInfectionDay}</p>\n//         <p>Total Days: {totalDays}</p>\n//         <p>Population Size: {populationSize}</p>\n//         <button onClick={handleSpeedChange}>\n//           {speed === 1\n//             ? \"Speed Up (2x)\"\n//             : speed === 2\n//             ? \"Speed Up (4x)\"\n//             : \"Reset Speed (1x)\"}\n//         </button>\n//         <Sketch setup={setup} draw={draw} />\n//       </div>\n//       {/* Right: Line Graph */}\n//       <div style={{ width: \"400px\" }}>\n//         <h3>Status Over Time</h3>\n//         <Line data={chartData} />\n//       </div>\n//   <button onClick={() => setShowModal(true)}>Add New</button>\n//       {/* Modal for adding new graph */}\n//       <Modal isOpen={showModal} onRequestClose={() => setShowModal(false)}>\n//         <h2>Enter New Parameters</h2>\n//         <ParameterForm onSubmit={addNewGraph} closeModal={() => setShowModal(false)} />\n//       </Modal>\n//       {/* Display all graphs */}\n//       {graphs.map((graph, index) => (\n//         <div key={index}>\n//           <h3>Graph {index + 1}</h3>\n//           <Line data={graph} />\n//         </div>\n//       ))}\n//     </div>\n//   );\n// }\n//------------------------------------------------\n//------------------------------------------------\n// \"use client\";\n// import { useSearchParams } from \"next/navigation\";\n// import { useEffect, useState, useRef } from \"react\";\n// import SimulationControls from \"./components/SimulationControls\";\n// import PopulationCanvas from \"./components/PopulationCanvas\";\n// import StatusChart from \"./components/StatusChart\";\n// import Person from \"./components/Person\";\n// type ChartData = {\n//   labels: number[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     borderColor: string;\n//     fill: boolean;\n//   }[];\n// };\n// export default function Simulation() {\n//   const searchParams = useSearchParams();\n//   const vaccineEfficacy = parseFloat(\n//     searchParams.get(\"vaccineEfficacy\") || \"0.8\"\n//   );\n//   const populationVaccinated = parseFloat(\n//     searchParams.get(\"populationVaccinated\") || \"0.7\"\n//   );\n//   const infectionProbability = parseFloat(\n//     searchParams.get(\"infectionProbability\") || \"0.5\"\n//   );\n//   const vaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"vaccinatedRecoveryRate\") || \"0.5\"\n//   );\n//   const unvaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"unvaccinatedRecoveryRate\") || \"0.1\"\n//   );\n//   const peakInfectionDay = parseInt(\n//     searchParams.get(\"peakInfectionDay\") || \"5\"\n//   );\n//   const totalDays = parseInt(searchParams.get(\"totalDays\") || \"30\");\n//   const populationSize = parseInt(searchParams.get(\"populationSize\") || \"250\");\n//   const [people, setPeople] = useState<Person[]>([]);\n//   const [speed, setSpeed] = useState(1);\n//   const [chartData, setChartData] = useState<ChartData>({\n//     labels: [],\n//     datasets: [\n//       { label: \"Healthy\", data: [], borderColor: \"blue\", fill: false },\n//       { label: \"Infected\", data: [], borderColor: \"red\", fill: false },\n//       { label: \"Recovered\", data: [], borderColor: \"green\", fill: false },\n//     ],\n//   });\n//   const updateChartData = (\n//     healthy: number,\n//     infected: number,\n//     recovered: number,\n//     frame: number\n//   ) => {\n//     setChartData((prevData) => ({\n//       labels: [...prevData.labels, frame],\n//       datasets: [\n//         {\n//           ...prevData.datasets[0],\n//           data: [...prevData.datasets[0].data, healthy],\n//         },\n//         {\n//           ...prevData.datasets[1],\n//           data: [...prevData.datasets[1].data, infected],\n//         },\n//         {\n//           ...prevData.datasets[2],\n//           data: [...prevData.datasets[2].data, recovered],\n//         },\n//       ],\n//     }));\n//   };\n//   const handleSpeedChange = () =>\n//     setSpeed((prev) => (prev === 1 ? 2 : prev === 2 ? 4 : 1));\n//   useEffect(() => {\n//     const newPeople: Person[] = [];\n//     for (let i = 0; i < populationSize; i++) {\n//       const x = Math.random() * 800;\n//       const y = Math.random() * 600;\n//       const vaccinated = Math.random() < populationVaccinated;\n//       newPeople.push(new Person(x, y, vaccinated));\n//     }\n//     setPeople(newPeople);\n//   }, [populationSize, populationVaccinated]);\n//   return (\n//     <div style={{ display: \"flex\", gap: \"20px\" }}>\n//       <SimulationControls\n//         vaccineEfficacy={vaccineEfficacy}\n//         populationVaccinated={populationVaccinated}\n//         infectionProbability={infectionProbability}\n//         vaccinatedRecoveryRate={vaccinatedRecoveryRate}\n//         unvaccinatedRecoveryRate={unvaccinatedRecoveryRate}\n//         peakInfectionDay={peakInfectionDay}\n//         totalDays={totalDays}\n//         populationSize={populationSize}\n//         speed={speed}\n//         handleSpeedChange={handleSpeedChange}\n//       />\n//       <PopulationCanvas\n//         people={people}\n//         vaccineEfficacy={vaccineEfficacy}\n//         infectionProbability={infectionProbability}\n//         vaccinatedRecoveryRate={vaccinatedRecoveryRate}\n//         unvaccinatedRecoveryRate={unvaccinatedRecoveryRate}\n//         totalDays={totalDays}\n//         updateChartData={updateChartData}\n//       />\n//       <StatusChart chartData={chartData} />\n//     </div>\n//   );\n// }\n//---------\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction Simulation() {\n    _s();\n    // State to manage list of simulations\n    const [simulations, setSimulations] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Function to add a new simulation\n    const addSimulation = (params)=>{\n        const newPeople = [];\n        for(let i = 0; i < params.populationSize; i++){\n            const x = Math.random() * 800;\n            const y = Math.random() * 600;\n            const vaccinated = Math.random() < params.populationVaccinated;\n            newPeople.push(new _components_Person__WEBPACK_IMPORTED_MODULE_6__[\"default\"](x, y, vaccinated));\n        }\n        // Chart Data Initial State\n        const initialChartData = {\n            labels: [],\n            datasets: [\n                {\n                    label: \"Healthy\",\n                    data: [],\n                    borderColor: \"blue\",\n                    fill: false\n                },\n                {\n                    label: \"Infected\",\n                    data: [],\n                    borderColor: \"red\",\n                    fill: false\n                },\n                {\n                    label: \"Recovered\",\n                    data: [],\n                    borderColor: \"green\",\n                    fill: false\n                }\n            ]\n        };\n        setSimulations((prevSimulations)=>[\n                ...prevSimulations,\n                {\n                    params,\n                    people: newPeople,\n                    chartData: initialChartData\n                }\n            ]);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            gap: \"20px\",\n            padding: \"20px\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    alignSelf: \"center\",\n                    marginTop: \"20px\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SimulationControlsPopover__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                    addSimulation: addSimulation\n                }, void 0, false, {\n                    fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                    lineNumber: 794,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                lineNumber: 793,\n                columnNumber: 7\n            }, this),\n            simulations.map((simulation, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        display: \"flex\",\n                        gap: \"20px\",\n                        marginBottom: \"40px\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                flex: 1,\n                                display: \"flex\",\n                                flexDirection: \"column\",\n                                gap: \"20px\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SimulationControls__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                    ...simulation.params,\n                                    speed: 1,\n                                    handleSpeedChange: ()=>{}\n                                }, void 0, false, {\n                                    fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                                    lineNumber: 809,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_PopulationCanvas__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    people: simulation.people,\n                                    vaccineEfficacy: simulation.params.vaccineEfficacy,\n                                    infectionProbability: simulation.params.infectionProbability,\n                                    vaccinatedRecoveryRate: simulation.params.vaccinatedRecoveryRate,\n                                    unvaccinatedRecoveryRate: simulation.params.unvaccinatedRecoveryRate,\n                                    totalDays: simulation.params.totalDays,\n                                    updateChartData: (healthy, infected, recovered, frame)=>{\n                                        setSimulations((prevSimulations)=>{\n                                            const updatedSimulations = [\n                                                ...prevSimulations\n                                            ];\n                                            updatedSimulations[index].chartData.labels.push(frame);\n                                            updatedSimulations[index].chartData.datasets[0].data.push(healthy);\n                                            updatedSimulations[index].chartData.datasets[1].data.push(infected);\n                                            updatedSimulations[index].chartData.datasets[2].data.push(recovered);\n                                            return updatedSimulations;\n                                        });\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                                    lineNumber: 810,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                            lineNumber: 801,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                flex: 1\n                            },\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_StatusChart__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                chartData: simulation.chartData\n                            }, void 0, false, {\n                                fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                                lineNumber: 832,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                            lineNumber: 831,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, index, true, {\n                    fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                    lineNumber: 799,\n                    columnNumber: 9\n                }, this))\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n        lineNumber: 791,\n        columnNumber: 5\n    }, this);\n}\n_s(Simulation, \"ZSD54RMO0QVpnLOVrRGbCqhGSX0=\");\n_c = Simulation;\nvar _c;\n$RefreshReg$(_c, \"Simulation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2ltdWxhdGlvbi9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxnQkFBZ0I7QUFFaEIscURBQXFEO0FBQ3JELHNDQUFzQztBQUN0Qyx1REFBdUQ7QUFDdkQsMENBQTBDO0FBQzFDLFdBQVc7QUFDWCxzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUVyQiwrRUFBK0U7QUFDL0UsZ0ZBQWdGO0FBQ2hGLGdCQUFnQjtBQUNoQixNQUFNO0FBQ04sa0NBQWtDO0FBQ2xDLDJFQUEyRTtBQUUzRSw0QkFBNEI7QUFDNUIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBRUwseUNBQXlDO0FBQ3pDLDRDQUE0QztBQUU1Qyx3Q0FBd0M7QUFDeEMsbURBQW1EO0FBQ25ELE9BQU87QUFDUCw2Q0FBNkM7QUFDN0Msd0RBQXdEO0FBQ3hELE9BQU87QUFDUCw2Q0FBNkM7QUFDN0Msd0RBQXdEO0FBQ3hELE9BQU87QUFFUCwrQ0FBK0M7QUFDL0MsMERBQTBEO0FBQzFELE9BQU87QUFFUCxpREFBaUQ7QUFDakQsNERBQTREO0FBQzVELE9BQU87QUFFUCx1Q0FBdUM7QUFDdkMsa0RBQWtEO0FBQ2xELE9BQU87QUFFUCx1RUFBdUU7QUFFdkUsa0ZBQWtGO0FBRWxGLHVFQUF1RTtBQUN2RSx3REFBd0Q7QUFDeEQsa0NBQWtDO0FBQ2xDLHlFQUF5RTtBQUV6RSxnQ0FBZ0M7QUFDaEMsa0VBQWtFO0FBRWxFLGtCQUFrQjtBQUNsQiw0REFBNEQ7QUFDNUQsaURBQWlEO0FBQ2pELGtCQUFrQjtBQUNsQixVQUFVO0FBQ1YsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQiwrQkFBK0I7QUFDL0Is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RixJQUFJLENBQUNtQzs0Q0FDaERDLGtCQUFrQixDQUFDZixNQUFNLENBQUNYLFNBQVMsQ0FBQ1AsUUFBUSxDQUFDLEVBQUUsQ0FBQ0UsSUFBSSxDQUFDTCxJQUFJLENBQUNnQzs0Q0FDMURJLGtCQUFrQixDQUFDZixNQUFNLENBQUNYLFNBQVMsQ0FBQ1AsUUFBUSxDQUFDLEVBQUUsQ0FBQ0UsSUFBSSxDQUFDTCxJQUFJLENBQUNpQzs0Q0FDMURHLGtCQUFrQixDQUFDZixNQUFNLENBQUNYLFNBQVMsQ0FBQ1AsUUFBUSxDQUFDLEVBQUUsQ0FBQ0UsSUFBSSxDQUFDTCxJQUFJLENBQUNrQzs0Q0FDMUQsT0FBT0U7d0NBQ1Q7b0NBQ0Y7Ozs7Ozs7Ozs7OztzQ0FLSiw4REFBQ3pCOzRCQUFJQyxPQUFPO2dDQUFFVyxNQUFNOzRCQUFFO3NDQUNwQiw0RUFBQ3hDLCtEQUFXQTtnQ0FBQzJCLFdBQVdVLFdBQVdWLFNBQVM7Ozs7Ozs7Ozs7OzttQkFqQ3RDVzs7Ozs7Ozs7Ozs7QUF1Q2xCO0dBbEZ3Qm5DO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvc2ltdWxhdGlvbi9wYWdlLnRzeD9hMzVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFwidXNlIGNsaWVudFwiO1xuXG4vLyBpbXBvcnQgeyB1c2VTZWFyY2hQYXJhbXMgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCI7XG4vLyBpbXBvcnQgZHluYW1pYyBmcm9tIFwibmV4dC9keW5hbWljXCI7XG4vLyBpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbi8vIGltcG9ydCB7IExpbmUgfSBmcm9tIFwicmVhY3QtY2hhcnRqcy0yXCI7XG4vLyBpbXBvcnQge1xuLy8gICBDaGFydCBhcyBDaGFydEpTLFxuLy8gICBMaW5lRWxlbWVudCxcbi8vICAgQ2F0ZWdvcnlTY2FsZSxcbi8vICAgTGluZWFyU2NhbGUsXG4vLyAgIFBvaW50RWxlbWVudCxcbi8vIH0gZnJvbSBcImNoYXJ0LmpzXCI7XG5cbi8vIC8vIER5bmFtaWNhbGx5IGxvYWQgcmVhY3QtcDUgc2luY2UgcDUuanMgcmVsaWVzIG9uIGJyb3dzZXItc3BlY2lmaWMgZmVhdHVyZXNcbi8vIGNvbnN0IFNrZXRjaCA9IGR5bmFtaWMoKCkgPT4gaW1wb3J0KFwicmVhY3QtcDVcIikudGhlbigobW9kKSA9PiBtb2QuZGVmYXVsdCksIHtcbi8vICAgc3NyOiBmYWxzZSxcbi8vIH0pO1xuLy8gLy8gUmVnaXN0ZXIgQ2hhcnQuanMgY29tcG9uZW50c1xuLy8gQ2hhcnRKUy5yZWdpc3RlcihMaW5lRWxlbWVudCwgQ2F0ZWdvcnlTY2FsZSwgTGluZWFyU2NhbGUsIFBvaW50RWxlbWVudCk7XG5cbi8vIC8vIERlZmluZSBjaGFydCBkYXRhIHR5cGVcbi8vIHR5cGUgQ2hhcnREYXRhID0ge1xuLy8gICBsYWJlbHM6IG51bWJlcltdO1xuLy8gICBkYXRhc2V0czoge1xuLy8gICAgIGxhYmVsOiBzdHJpbmc7XG4vLyAgICAgZGF0YTogbnVtYmVyW107XG4vLyAgICAgYm9yZGVyQ29sb3I6IHN0cmluZztcbi8vICAgICBmaWxsOiBib29sZWFuO1xuLy8gICB9W107XG4vLyB9O1xuXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaW11bGF0aW9uKCkge1xuLy8gICBjb25zdCBzZWFyY2hQYXJhbXMgPSB1c2VTZWFyY2hQYXJhbXMoKTtcblxuLy8gICBjb25zdCB2YWNjaW5lRWZmaWNhY3kgPSBwYXJzZUZsb2F0KFxuLy8gICAgIHNlYXJjaFBhcmFtcy5nZXQoXCJ2YWNjaW5lRWZmaWNhY3lcIikgfHwgXCIwLjhcIlxuLy8gICApO1xuLy8gICBjb25zdCBwb3B1bGF0aW9uVmFjY2luYXRlZCA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInBvcHVsYXRpb25WYWNjaW5hdGVkXCIpIHx8IFwiMC43XCJcbi8vICAgKTtcbi8vICAgY29uc3QgaW5mZWN0aW9uUHJvYmFiaWxpdHkgPSBwYXJzZUZsb2F0KFxuLy8gICAgIHNlYXJjaFBhcmFtcy5nZXQoXCJpbmZlY3Rpb25Qcm9iYWJpbGl0eVwiKSB8fCBcIjAuNVwiXG4vLyAgICk7XG5cbi8vICAgY29uc3QgdmFjY2luYXRlZFJlY292ZXJ5UmF0ZSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInZhY2NpbmF0ZWRSZWNvdmVyeVJhdGVcIikgfHwgXCIwLjVcIlxuLy8gICApO1xuXG4vLyAgIGNvbnN0IHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZVwiKSB8fCBcIjAuMVwiXG4vLyAgICk7XG5cbi8vICAgY29uc3QgcGVha0luZmVjdGlvbkRheSA9IHBhcnNlSW50KFxuLy8gICAgIHNlYXJjaFBhcmFtcy5nZXQoXCJwZWFrSW5mZWN0aW9uRGF5XCIpIHx8IFwiNVwiXG4vLyAgICk7XG5cbi8vICAgY29uc3QgdG90YWxEYXlzID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldChcInRvdGFsRGF5c1wiKSB8fCBcIjMwXCIpO1xuXG4vLyAgIGNvbnN0IHBvcHVsYXRpb25TaXplID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldChcInBvcHVsYXRpb25TaXplXCIpIHx8IFwiMjUwXCIpO1xuXG4vLyAgIC8vIFBvcHVsYXRpb24gYXJyYXkgbWFuYWdlZCBvdXRzaWRlIG9mIFJlYWN0IHN0YXRlIGZvciBwZXJmb3JtYW5jZVxuLy8gICBjb25zdCBbcGVvcGxlLCBzZXRQZW9wbGVdID0gdXNlU3RhdGU8UGVyc29uW10+KFtdKTtcbi8vICAgLy9jb25zdCBwb3B1bGF0aW9uU2l6ZSA9IDEwMDtcbi8vICAgY29uc3QgcDVJbnN0YW5jZSA9IHVzZVJlZjxhbnk+KG51bGwpOyAvLyBSZWZlcmVuY2UgdG8gcDUuanMgaW5zdGFuY2VcblxuLy8gICAvLyBTaW11bGF0aW9uIHNwZWVkIGNvbnRyb2xcbi8vICAgY29uc3QgW3NwZWVkLCBzZXRTcGVlZF0gPSB1c2VTdGF0ZSgxKTsgLy8gMXggc3BlZWQgYnkgZGVmYXVsdFxuXG4vLyAgIC8vIENoYXJ0IGRhdGFcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPENoYXJ0RGF0YT4oe1xuLy8gICAgIGxhYmVsczogW10sIC8vIEZyYW1lIGNvdW50IChvciB0aW1lIHN0ZXBzKVxuLy8gICAgIGRhdGFzZXRzOiBbXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGxhYmVsOiBcIkhlYWx0aHlcIixcbi8vICAgICAgICAgZGF0YTogW10sXG4vLyAgICAgICAgIGJvcmRlckNvbG9yOiBcImJsdWVcIixcbi8vICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICB9LFxuLy8gICAgICAge1xuLy8gICAgICAgICBsYWJlbDogXCJJbmZlY3RlZFwiLFxuLy8gICAgICAgICBkYXRhOiBbXSxcbi8vICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmVkXCIsXG4vLyAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgfSxcbi8vICAgICAgIHtcbi8vICAgICAgICAgbGFiZWw6IFwiUmVjb3ZlcmVkXCIsXG4vLyAgICAgICAgIGRhdGE6IFtdLFxuLy8gICAgICAgICBib3JkZXJDb2xvcjogXCJncmVlblwiLFxuLy8gICAgICAgICBmaWxsOiBmYWxzZSxcbi8vICAgICAgIH0sXG4vLyAgICAgXSxcbi8vICAgfSk7XG4vLyAgIGNvbnN0IGZyYW1lQ291bnQgPSB1c2VSZWYoMCk7IC8vIEtlZXAgdHJhY2sgb2YgdGhlIHNpbXVsYXRpb24gZnJhbWVzXG5cbi8vICAgLy8gUGVyc29uIG9iamVjdCByZXByZXNlbnRpbmcgZWFjaCBpbmRpdmlkdWFsIGluIHRoZSBwb3B1bGF0aW9uXG4vLyAgIGNsYXNzIFBlcnNvbiB7XG4vLyAgICAgeDogbnVtYmVyO1xuLy8gICAgIHk6IG51bWJlcjtcbi8vICAgICBzdGF0dXM6IHN0cmluZzsgLy8gJ2hlYWx0aHknLCAnaW5mZWN0ZWQnLCAncmVjb3ZlcmVkJ1xuLy8gICAgIHZhY2NpbmF0ZWQ6IGJvb2xlYW47XG5cbi8vICAgICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgdmFjY2luYXRlZDogYm9vbGVhbiwgc3RhdHVzID0gXCJoZWFsdGh5XCIpIHtcbi8vICAgICAgIHRoaXMueCA9IHg7XG4vLyAgICAgICB0aGlzLnkgPSB5O1xuLy8gICAgICAgdGhpcy52YWNjaW5hdGVkID0gdmFjY2luYXRlZDtcbi8vICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuLy8gICAgIH1cblxuLy8gICAgIC8vIERldGVybWluZSBpZiBhIHBlcnNvbiBjYW4gZ2V0IGluZmVjdGVkXG4vLyAgICAgdHJ5VG9JbmZlY3QocDU6IGFueSwgaW5mZWN0aW9uUmFkaXVzOiBudW1iZXIpIHtcbi8vICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJoZWFsdGh5XCIpIHtcbi8vICAgICAgICAgZm9yIChsZXQgb3RoZXIgb2YgcGVvcGxlKSB7XG4vLyAgICAgICAgICAgaWYgKG90aGVyLnN0YXR1cyA9PT0gXCJpbmZlY3RlZFwiKSB7XG4vLyAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHBlcnNvbiBpcyB3aXRoaW4gaW5mZWN0aW9uIHJhZGl1c1xuLy8gICAgICAgICAgICAgbGV0IGQgPSBwNS5kaXN0KHRoaXMueCwgdGhpcy55LCBvdGhlci54LCBvdGhlci55KTtcbi8vICAgICAgICAgICAgIGlmIChkIDwgaW5mZWN0aW9uUmFkaXVzKSB7XG4vLyAgICAgICAgICAgICAgIC8vIENoZWNrIHZhY2NpbmF0aW9uIHN0YXR1cyBhbmQgaW5mZWN0aW9uIHByb2JhYmlsaXR5XG4vLyAgICAgICAgICAgICAgIGlmICghdGhpcy52YWNjaW5hdGVkIHx8IE1hdGgucmFuZG9tKCkgPiB2YWNjaW5lRWZmaWNhY3kpIHtcbi8vICAgICAgICAgICAgICAgICAvLyBSYW5kb20gY2hhbmNlIG9mIGluZmVjdGlvblxuLy8gICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgaW5mZWN0aW9uUHJvYmFiaWxpdHkpIHtcbi8vICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gXCJpbmZlY3RlZFwiOyAvLyBUaGlzIHBlcnNvbiBnZXRzIGluZmVjdGVkXG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG4vLyAgICAgICB9XG4vLyAgICAgfVxuXG4vLyAgICAgbW92ZShwNTogYW55KSB7XG4vLyAgICAgICB0aGlzLnggKz0gcDUucmFuZG9tKC01LCA1KTsgLy8gSW5jcmVhc2VkIG1vdmVtZW50XG4vLyAgICAgICB0aGlzLnkgKz0gcDUucmFuZG9tKC01LCA1KTtcbi8vICAgICAgIHRoaXMueCA9IHA1LmNvbnN0cmFpbih0aGlzLngsIDAsIHA1LndpZHRoKTtcbi8vICAgICAgIHRoaXMueSA9IHA1LmNvbnN0cmFpbih0aGlzLnksIDAsIHA1LmhlaWdodCk7XG4vLyAgICAgfVxuXG4vLyAgICAgc2hvdyhwNTogYW55KSB7XG4vLyAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiaGVhbHRoeVwiKSB7XG4vLyAgICAgICAgIHA1LmZpbGwoMTAwLCAyMDAsIDI1NSk7IC8vIGJsdWUgZm9yIGhlYWx0aHlcbi8vICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IFwiaW5mZWN0ZWRcIikge1xuLy8gICAgICAgICBwNS5maWxsKDI1NSwgMTAwLCAxMDApOyAvLyByZWQgZm9yIGluZmVjdGVkXG4vLyAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBcInJlY292ZXJlZFwiKSB7XG4vLyAgICAgICAgIHA1LmZpbGwoMCwgMjU1LCAwKTsgLy8gZ3JlZW4gZm9yIHJlY292ZXJlZFxuLy8gICAgICAgfVxuLy8gICAgICAgcDUuZWxsaXBzZSh0aGlzLngsIHRoaXMueSwgMjAsIDIwKTtcbi8vICAgICB9XG5cbi8vICAgICAvLyByZWNvdmVyKCkge1xuLy8gICAgIC8vICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImluZmVjdGVkXCIgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDEpIHtcbi8vICAgICAvLyAgICAgdGhpcy5zdGF0dXMgPSBcInJlY292ZXJlZFwiO1xuLy8gICAgIC8vICAgfVxuLy8gICAgIC8vIH1cbi8vICAgICAvLyBuZXcgcmVjb3ZlciBmdW5jdGlvbiBuZWVkZWRcblxuLy8gICAgIHJlY292ZXIoKSB7XG4vLyAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiaW5mZWN0ZWRcIikge1xuLy8gICAgICAgICBjb25zdCByZWNvdmVyeUNoYW5jZSA9IHRoaXMudmFjY2luYXRlZFxuLy8gICAgICAgICAgID8gdmFjY2luYXRlZFJlY292ZXJ5UmF0ZVxuLy8gICAgICAgICAgIDogdW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlO1xuLy8gICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IHJlY292ZXJ5Q2hhbmNlKSB7XG4vLyAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlY292ZXJlZFwiO1xuLy8gICAgICAgICB9XG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG5cbi8vICAgLy8gSW5pdGlhbGl6ZSBwb3B1bGF0aW9uIG9uY2UgaW4gdXNlRWZmZWN0XG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XG4vLyAgICAgaWYgKHBlb3BsZS5sZW5ndGggPT09IDApIHtcbi8vICAgICAgIGNvbnN0IG5ld1Blb3BsZTogUGVyc29uW10gPSBbXTtcbi8vICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9wdWxhdGlvblNpemU7IGkrKykge1xuLy8gICAgICAgICBsZXQgeCA9IE1hdGgucmFuZG9tKCkgKiA4MDA7XG4vLyAgICAgICAgIGxldCB5ID0gTWF0aC5yYW5kb20oKSAqIDYwMDtcbi8vICAgICAgICAgbGV0IHZhY2NpbmF0ZWQgPSBNYXRoLnJhbmRvbSgpIDwgcG9wdWxhdGlvblZhY2NpbmF0ZWQ7XG4vLyAgICAgICAgIG5ld1Blb3BsZS5wdXNoKG5ldyBQZXJzb24oeCwgeSwgdmFjY2luYXRlZCkpO1xuLy8gICAgICAgfVxuLy8gICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4vLyAgICAgICAgIG5ld1Blb3BsZVtpXS5zdGF0dXMgPSBcImluZmVjdGVkXCI7IC8vIHNldHRpbmcgdG8gaW5mZWN0ZWQgZnJvbSBzdGFydFxuLy8gICAgICAgfVxuLy8gICAgICAgc2V0UGVvcGxlKG5ld1Blb3BsZSk7XG4vLyAgICAgfVxuLy8gICB9LCBbXSk7IC8vIEVtcHR5IGRlcGVuZGVuY3kgYXJyYXkgZW5zdXJlcyBwZW9wbGUgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZVxuXG4vLyAgIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjaGFydCBkYXRhXG4vLyAgIGNvbnN0IHVwZGF0ZUNoYXJ0RGF0YSA9IChcbi8vICAgICBoZWFsdGh5OiBudW1iZXIsXG4vLyAgICAgaW5mZWN0ZWQ6IG51bWJlcixcbi8vICAgICByZWNvdmVyZWQ6IG51bWJlcixcbi8vICAgICBmcmFtZTogbnVtYmVyXG4vLyAgICkgPT4ge1xuLy8gICAgIHNldENoYXJ0RGF0YSgocHJldkRhdGEpID0+ICh7XG4vLyAgICAgICBsYWJlbHM6IFsuLi5wcmV2RGF0YS5sYWJlbHMsIGZyYW1lXSwgLy8gQXBwZW5kIHRoZSBuZXcgZnJhbWUgY291bnRcbi8vICAgICAgIGRhdGFzZXRzOiBbXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICAuLi5wcmV2RGF0YS5kYXRhc2V0c1swXSxcbi8vICAgICAgICAgICBkYXRhOiBbLi4ucHJldkRhdGEuZGF0YXNldHNbMF0uZGF0YSwgaGVhbHRoeV0sIC8vIEFwcGVuZCB0aGUgbmV3IGhlYWx0aHkgY291bnRcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIC4uLnByZXZEYXRhLmRhdGFzZXRzWzFdLFxuLy8gICAgICAgICAgIGRhdGE6IFsuLi5wcmV2RGF0YS5kYXRhc2V0c1sxXS5kYXRhLCBpbmZlY3RlZF0sIC8vIEFwcGVuZCB0aGUgbmV3IGluZmVjdGVkIGNvdW50XG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICAuLi5wcmV2RGF0YS5kYXRhc2V0c1syXSxcbi8vICAgICAgICAgICBkYXRhOiBbLi4ucHJldkRhdGEuZGF0YXNldHNbMl0uZGF0YSwgcmVjb3ZlcmVkXSwgLy8gQXBwZW5kIHRoZSBuZXcgcmVjb3ZlcmVkIGNvdW50XG4vLyAgICAgICAgIH0sXG4vLyAgICAgICBdLFxuLy8gICAgIH0pKTtcbi8vICAgfTtcblxuLy8gICAvLyBwNS5qcyBzZXR1cCBhbmQgZHJhdyBmdW5jdGlvbnNcbi8vICAgY29uc3Qgc2V0dXAgPSAocDU6IGFueSwgY2FudmFzUGFyZW50UmVmOiBFbGVtZW50KSA9PiB7XG4vLyAgICAgcDUuY3JlYXRlQ2FudmFzKDgwMCwgNjAwKS5wYXJlbnQoY2FudmFzUGFyZW50UmVmKTtcbi8vICAgICBwNUluc3RhbmNlLmN1cnJlbnQgPSBwNTsgLy8gU2F2ZSBwNS5qcyBpbnN0YW5jZSBmb3IgZnV0dXJlIHJlZmVyZW5jZVxuLy8gICAgIHA1LmZyYW1lUmF0ZSgzMCk7IC8vIFNldCBkZWZhdWx0IGZyYW1lIHJhdGVcbi8vICAgfTtcblxuLy8gICBjb25zdCBkcmF3ID0gKHA1OiBhbnkpID0+IHtcbi8vICAgICBwNS5iYWNrZ3JvdW5kKDI1NSk7XG5cbi8vICAgICBsZXQgaGVhbHRoeUNvdW50ID0gMDtcbi8vICAgICBsZXQgaW5mZWN0ZWRDb3VudCA9IDA7XG4vLyAgICAgbGV0IHJlY292ZXJlZENvdW50ID0gMDtcblxuLy8gICAgIC8vIFJlbmRlciBhbmQgdXBkYXRlIGVhY2ggcGVyc29uXG4vLyAgICAgcGVvcGxlLmZvckVhY2goKHBlcnNvbikgPT4ge1xuLy8gICAgICAgcGVyc29uLm1vdmUocDUpO1xuLy8gICAgICAgcGVyc29uLnNob3cocDUpO1xuLy8gICAgICAgcGVyc29uLnRyeVRvSW5mZWN0KHA1LCA1MCk7IC8vIEluZmVjdGlvbiByYWRpdXMgaXMgNTAgcGl4ZWxzXG4vLyAgICAgICBwZXJzb24ucmVjb3ZlcigpO1xuXG4vLyAgICAgICAvLyBDb3VudCBwZW9wbGUgYnkgdGhlaXIgc3RhdHVzXG4vLyAgICAgICBpZiAocGVyc29uLnN0YXR1cyA9PT0gXCJoZWFsdGh5XCIpIGhlYWx0aHlDb3VudCsrO1xuLy8gICAgICAgaWYgKHBlcnNvbi5zdGF0dXMgPT09IFwiaW5mZWN0ZWRcIikgaW5mZWN0ZWRDb3VudCsrO1xuLy8gICAgICAgaWYgKHBlcnNvbi5zdGF0dXMgPT09IFwicmVjb3ZlcmVkXCIpIHJlY292ZXJlZENvdW50Kys7XG4vLyAgICAgfSk7XG5cbi8vICAgICBpZiAoZnJhbWVDb3VudC5jdXJyZW50ID4gdG90YWxEYXlzICogMzApIHtcbi8vICAgICAgIHA1Lm5vTG9vcCgpO1xuLy8gICAgIH1cbi8vICAgICAvLyBVcGRhdGUgdGhlIGNoYXJ0IGV2ZXJ5IGZyYW1lXG4vLyAgICAgZnJhbWVDb3VudC5jdXJyZW50Kys7XG4vLyAgICAgdXBkYXRlQ2hhcnREYXRhKFxuLy8gICAgICAgaGVhbHRoeUNvdW50LFxuLy8gICAgICAgaW5mZWN0ZWRDb3VudCxcbi8vICAgICAgIHJlY292ZXJlZENvdW50LFxuLy8gICAgICAgZnJhbWVDb3VudC5jdXJyZW50XG4vLyAgICAgKTtcbi8vICAgfTtcblxuLy8gICAvLyBIYW5kbGUgc3BlZWQgY2hhbmdlcyB1c2luZyBwNSdzIGZyYW1lUmF0ZSgpXG4vLyAgIGNvbnN0IGhhbmRsZVNwZWVkQ2hhbmdlID0gKCkgPT4ge1xuLy8gICAgIGlmIChzcGVlZCA9PT0gMSkge1xuLy8gICAgICAgc2V0U3BlZWQoMik7IC8vIFNwZWVkIHVwIHRvIDJ4XG4vLyAgICAgICBwNUluc3RhbmNlLmN1cnJlbnQuZnJhbWVSYXRlKDYwKTsgLy8gRG91YmxlIHRoZSBmcmFtZSByYXRlIGZvciAyeCBzcGVlZFxuLy8gICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDIpIHtcbi8vICAgICAgIHNldFNwZWVkKDQpOyAvLyBTcGVlZCB1cCB0byA0eFxuLy8gICAgICAgcDVJbnN0YW5jZS5jdXJyZW50LmZyYW1lUmF0ZSgxMjApOyAvLyBRdWFkcnVwbGUgdGhlIGZyYW1lIHJhdGUgZm9yIDR4IHNwZWVkXG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIHNldFNwZWVkKDEpOyAvLyBSZXNldCB0byAxeCBzcGVlZFxuLy8gICAgICAgcDVJbnN0YW5jZS5jdXJyZW50LmZyYW1lUmF0ZSgzMCk7IC8vIERlZmF1bHQgZnJhbWUgcmF0ZVxuLy8gICAgIH1cbi8vICAgfTtcblxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGdhcDogXCIyMHB4XCIgfX0+XG4vLyAgICAgICB7LyogTGVmdDogU2ltdWxhdGlvbiAqL31cbi8vICAgICAgIDxkaXY+XG4vLyAgICAgICAgIDxoMj5GbHUgU2ltdWxhdGlvbjwvaDI+XG4vLyAgICAgICAgIDxwPlZhY2NpbmUgRWZmaWNhY3k6IHtNYXRoLnJvdW5kKHZhY2NpbmVFZmZpY2FjeSAqIDEwMCl9JTwvcD5cbi8vICAgICAgICAgPHA+UG9wdWxhdGlvbiBWYWNjaW5hdGVkOiB7TWF0aC5yb3VuZChwb3B1bGF0aW9uVmFjY2luYXRlZCAqIDEwMCl9JTwvcD5cbi8vICAgICAgICAgPHA+SW5mZWN0aW9uIFByb2JhYmlsaXR5OiB7TWF0aC5yb3VuZChpbmZlY3Rpb25Qcm9iYWJpbGl0eSAqIDEwMCl9JTwvcD5cbi8vICAgICAgICAgPHA+XG4vLyAgICAgICAgICAge1wiIFwifVxuLy8gICAgICAgICAgIFZhY2NpbmF0ZWQgUmVjb3ZlcnkgUmF0ZToge01hdGgucm91bmQodmFjY2luYXRlZFJlY292ZXJ5UmF0ZSAqIDEwMCl9JVxuLy8gICAgICAgICA8L3A+XG4vLyAgICAgICAgIDxwPlxuLy8gICAgICAgICAgIFVudmFjY2luYXRlZCBSZWNvdmVyeSBSYXRlOntcIiBcIn1cbi8vICAgICAgICAgICB7TWF0aC5yb3VuZCh1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGUgKiAxMDApfSVcbi8vICAgICAgICAgPC9wPlxuLy8gICAgICAgICA8cD5QZWFrIEluZmVjdGlvbiBEYXk6IHtwZWFrSW5mZWN0aW9uRGF5fTwvcD5cbi8vICAgICAgICAgPHA+VG90YWwgRGF5czoge3RvdGFsRGF5c308L3A+XG4vLyAgICAgICAgIDxwPlBvcHVsYXRpb24gU2l6ZToge3BvcHVsYXRpb25TaXplfTwvcD5cblxuLy8gICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e2hhbmRsZVNwZWVkQ2hhbmdlfT5cbi8vICAgICAgICAgICB7c3BlZWQgPT09IDFcbi8vICAgICAgICAgICAgID8gXCJTcGVlZCBVcCAoMngpXCJcbi8vICAgICAgICAgICAgIDogc3BlZWQgPT09IDJcbi8vICAgICAgICAgICAgID8gXCJTcGVlZCBVcCAoNHgpXCJcbi8vICAgICAgICAgICAgIDogXCJSZXNldCBTcGVlZCAoMXgpXCJ9XG4vLyAgICAgICAgIDwvYnV0dG9uPlxuXG4vLyAgICAgICAgIDxTa2V0Y2ggc2V0dXA9e3NldHVwfSBkcmF3PXtkcmF3fSAvPlxuLy8gICAgICAgPC9kaXY+XG5cbi8vICAgICAgIHsvKiBSaWdodDogTGluZSBHcmFwaCAqL31cbi8vICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6IFwiNDAwcHhcIiB9fT5cbi8vICAgICAgICAgPGgzPlN0YXR1cyBPdmVyIFRpbWU8L2gzPlxuLy8gICAgICAgICA8TGluZSBkYXRhPXtjaGFydERhdGF9IC8+XG4vLyAgICAgICA8L2Rpdj5cbi8vICAgICA8L2Rpdj5cbi8vICAgKTtcbi8vIH1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gXCJ1c2UgY2xpZW50XCI7XG5cbi8vIGltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbi8vIGltcG9ydCBkeW5hbWljIGZyb20gXCJuZXh0L2R5bmFtaWNcIjtcbi8vIGltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuLy8gaW1wb3J0IHsgTGluZSB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcbi8vIGltcG9ydCB7XG4vLyAgIENoYXJ0IGFzIENoYXJ0SlMsXG4vLyAgIExpbmVFbGVtZW50LFxuLy8gICBDYXRlZ29yeVNjYWxlLFxuLy8gICBMaW5lYXJTY2FsZSxcbi8vICAgUG9pbnRFbGVtZW50LFxuLy8gfSBmcm9tIFwiY2hhcnQuanNcIjtcbi8vIGltcG9ydCBNb2RhbCBmcm9tICdyZWFjdC1tb2RhbCc7XG5cbi8vIC8vIER5bmFtaWNhbGx5IGxvYWQgcmVhY3QtcDUgc2luY2UgcDUuanMgcmVsaWVzIG9uIGJyb3dzZXItc3BlY2lmaWMgZmVhdHVyZXNcbi8vIGNvbnN0IFNrZXRjaCA9IGR5bmFtaWMoKCkgPT4gaW1wb3J0KFwicmVhY3QtcDVcIikudGhlbigobW9kKSA9PiBtb2QuZGVmYXVsdCksIHtcbi8vICAgc3NyOiBmYWxzZSxcbi8vIH0pO1xuXG4vLyAvLyBSZWdpc3RlciBDaGFydC5qcyBjb21wb25lbnRzXG4vLyBDaGFydEpTLnJlZ2lzdGVyKExpbmVFbGVtZW50LCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgUG9pbnRFbGVtZW50KTtcblxuLy8gLy8gRGVmaW5lIGNoYXJ0IGRhdGEgdHlwZVxuLy8gdHlwZSBDaGFydERhdGEgPSB7XG4vLyAgIGxhYmVsczogbnVtYmVyW107XG4vLyAgIGRhdGFzZXRzOiB7XG4vLyAgICAgbGFiZWw6IHN0cmluZztcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcbi8vICAgICBib3JkZXJDb2xvcjogc3RyaW5nO1xuLy8gICAgIGZpbGw6IGJvb2xlYW47XG4vLyAgICAgYm9yZGVyRGFzaD86IG51bWJlcltdO1xuLy8gICB9W107XG4vLyB9O1xuXG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaW11bGF0aW9uKCkge1xuXG4vLyAgIGNvbnN0IFtzaG93TW9kYWwsIHNldFNob3dNb2RhbF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4vLyAgIGNvbnN0IFtncmFwaHMsIHNldEdyYXBoc10gPSB1c2VTdGF0ZShbXSk7XG4vLyAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZVNlYXJjaFBhcmFtcygpO1xuXG4vLyAgIGNvbnN0IGFkZE5ld0dyYXBoID0gKG5ld1BhcmFtcyk9PiB7XG4vLyAgICAgY29uc3QgbmV3R3JhcGhEYXRhID0gcnVuU2ltdWxhdGlvbihuZXdQYXJhbXMpO1xuLy8gICAgIHNldEdyYXBocyhbLi4uZ3JhcGhzLCBuZXdHcmFwaERhdGFdKTtcbi8vICAgICBzZXRTaG93TW9kYWwoZmFsc2UpO1xuLy8gICB9XG5cbi8vICAgLy8gRXh0cmFjdCBwYXJhbWV0ZXJzIGZyb20gVVJMXG4vLyAgIGNvbnN0IHZhY2NpbmVFZmZpY2FjeSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInZhY2NpbmVFZmZpY2FjeVwiKSB8fCBcIjAuOFwiXG4vLyAgICk7XG4vLyAgIGNvbnN0IHBvcHVsYXRpb25WYWNjaW5hdGVkID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwicG9wdWxhdGlvblZhY2NpbmF0ZWRcIikgfHwgXCIwLjdcIlxuLy8gICApO1xuLy8gICBjb25zdCBpbmZlY3Rpb25Qcm9iYWJpbGl0eSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcImluZmVjdGlvblByb2JhYmlsaXR5XCIpIHx8IFwiMC41XCJcbi8vICAgKTtcbi8vICAgY29uc3QgdmFjY2luYXRlZFJlY292ZXJ5UmF0ZSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInZhY2NpbmF0ZWRSZWNvdmVyeVJhdGVcIikgfHwgXCIwLjVcIlxuLy8gICApO1xuLy8gICBjb25zdCB1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGUgPSBwYXJzZUZsb2F0KFxuLy8gICAgIHNlYXJjaFBhcmFtcy5nZXQoXCJ1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGVcIikgfHwgXCIwLjFcIlxuLy8gICApO1xuLy8gICBjb25zdCBwZWFrSW5mZWN0aW9uRGF5ID0gcGFyc2VJbnQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInBlYWtJbmZlY3Rpb25EYXlcIikgfHwgXCI1XCJcbi8vICAgKTtcbi8vICAgY29uc3QgdG90YWxEYXlzID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldChcInRvdGFsRGF5c1wiKSB8fCBcIjMwXCIpO1xuLy8gICBjb25zdCBwb3B1bGF0aW9uU2l6ZSA9IHBhcnNlSW50KHNlYXJjaFBhcmFtcy5nZXQoXCJwb3B1bGF0aW9uU2l6ZVwiKSB8fCBcIjEwMFwiKTtcblxuLy8gICAvLyBTdGF0ZSBmb3Igc2ltdWxhdGlvbiBkYXRhXG4vLyAgIGNvbnN0IFtkYXlzLCBzZXREYXlzXSA9IHVzZVN0YXRlPG51bWJlcltdPihbXSk7XG4vLyAgIGNvbnN0IFtzdXNjZXB0aWJsZVBvcHVsYXRpb24sIHNldFN1c2NlcHRpYmxlUG9wdWxhdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXJbXT4oXG4vLyAgICAgW11cbi8vICAgKTtcbi8vICAgY29uc3QgW2luZmVjdGVkUG9wdWxhdGlvbiwgc2V0SW5mZWN0ZWRQb3B1bGF0aW9uXSA9IHVzZVN0YXRlPG51bWJlcltdPihbXSk7XG4vLyAgIGNvbnN0IFtyZWNvdmVyZWRWYWNjaW5hdGVkLCBzZXRSZWNvdmVyZWRWYWNjaW5hdGVkXSA9IHVzZVN0YXRlPG51bWJlcltdPihbXSk7XG4vLyAgIGNvbnN0IFtyZWNvdmVyZWRVbnZhY2NpbmF0ZWQsIHNldFJlY292ZXJlZFVudmFjY2luYXRlZF0gPSB1c2VTdGF0ZTxudW1iZXJbXT4oXG4vLyAgICAgW11cbi8vICAgKTtcbi8vICAgY29uc3QgW3RvdGFsUmVjb3ZlcmVkUG9wdWxhdGlvbiwgc2V0VG90YWxSZWNvdmVyZWRQb3B1bGF0aW9uXSA9IHVzZVN0YXRlPFxuLy8gICAgIG51bWJlcltdXG4vLyAgID4oW10pO1xuLy8gICBjb25zdCBbc3BlZWQsIHNldFNwZWVkXSA9IHVzZVN0YXRlKDEpOyAvLyAxeCBzcGVlZCBieSBkZWZhdWx0XG5cbi8vICAgY29uc3QgcDVJbnN0YW5jZSA9IHVzZVJlZjxhbnk+KG51bGwpOyAvLyBSZWZlcmVuY2UgdG8gcDUuanMgaW5zdGFuY2VcblxuLy8gICAvLyBDaGFydCBkYXRhXG4vLyAgIGNvbnN0IFtjaGFydERhdGEsIHNldENoYXJ0RGF0YV0gPSB1c2VTdGF0ZTxDaGFydERhdGE+KHtcbi8vICAgICBsYWJlbHM6IFtdLCAvLyBGcmFtZSBjb3VudCAob3IgdGltZSBzdGVwcylcbi8vICAgICBkYXRhc2V0czogW1xuLy8gICAgICAge1xuLy8gICAgICAgICBsYWJlbDogXCJTdXNjZXB0aWJsZVwiLFxuLy8gICAgICAgICBkYXRhOiBbXSxcbi8vICAgICAgICAgYm9yZGVyQ29sb3I6IFwib3JhbmdlXCIsXG4vLyAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgfSxcbi8vICAgICAgIHtcbi8vICAgICAgICAgbGFiZWw6IFwiSW5mZWN0ZWRcIixcbi8vICAgICAgICAgZGF0YTogW10sXG4vLyAgICAgICAgIGJvcmRlckNvbG9yOiBcInJlZFwiLFxuLy8gICAgICAgICBmaWxsOiBmYWxzZSxcbi8vICAgICAgIH0sXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGxhYmVsOiBcIlRvdGFsIFJlY292ZXJlZFwiLFxuLy8gICAgICAgICBkYXRhOiBbXSxcbi8vICAgICAgICAgYm9yZGVyQ29sb3I6IFwiZ3JlZW5cIixcbi8vICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICB9LFxuLy8gICAgICAge1xuLy8gICAgICAgICBsYWJlbDogXCJSZWNvdmVyZWQgVmFjY2luYXRlZFwiLFxuLy8gICAgICAgICBkYXRhOiBbXSxcbi8vICAgICAgICAgYm9yZGVyQ29sb3I6IFwiYmx1ZVwiLFxuLy8gICAgICAgICBib3JkZXJEYXNoOiBbNSwgNV0sXG4vLyAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgfSxcbi8vICAgICAgIHtcbi8vICAgICAgICAgbGFiZWw6IFwiUmVjb3ZlcmVkIFVudmFjY2luYXRlZFwiLFxuLy8gICAgICAgICBkYXRhOiBbXSxcbi8vICAgICAgICAgYm9yZGVyQ29sb3I6IFwicHVycGxlXCIsXG4vLyAgICAgICAgIGJvcmRlckRhc2g6IFs1LCA1XSxcbi8vICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICB9LFxuLy8gICAgIF0sXG4vLyAgIH0pO1xuXG4vLyAgIC8vIEluaXRpYWxpemUgYW5kIGNhbGN1bGF0ZSBmbHUgbW9kZWwgZGF0YVxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xuLy8gICAgIGNvbnN0IGRheXNBcnJheSA9IEFycmF5LmZyb20oXG4vLyAgICAgICB7IGxlbmd0aDogMTAwIH0sXG4vLyAgICAgICAoXywgaSkgPT4gKGkgLyAxMDApICogdG90YWxEYXlzXG4vLyAgICAgKTtcbi8vICAgICBzZXREYXlzKGRheXNBcnJheSk7XG5cbi8vICAgICBjb25zdCB2YWNjaW5hdGVkUG9wdWxhdGlvbiA9IHBvcHVsYXRpb25TaXplICogcG9wdWxhdGlvblZhY2NpbmF0ZWQ7XG4vLyAgICAgY29uc3QgdW52YWNjaW5hdGVkUG9wdWxhdGlvbiA9IHBvcHVsYXRpb25TaXplICogKDEgLSBwb3B1bGF0aW9uVmFjY2luYXRlZCk7XG5cbi8vICAgICAvLyBDYWxjdWxhdGUgcmVjb3ZlcmVkIHBvcHVsYXRpb25cbi8vICAgICBjb25zdCByZWNvdmVyZWRWYWNjaW5hdGVkQXJyYXkgPSBkYXlzQXJyYXkubWFwKFxuLy8gICAgICAgKGRheSkgPT5cbi8vICAgICAgICAgKDEgLyAoMSArIE1hdGguZXhwKC12YWNjaW5hdGVkUmVjb3ZlcnlSYXRlICogKGRheSAtIHRvdGFsRGF5cyAvIDIpKSkpICpcbi8vICAgICAgICAgdmFjY2luYXRlZFBvcHVsYXRpb25cbi8vICAgICApO1xuXG4vLyAgICAgY29uc3QgcmVjb3ZlcmVkVW52YWNjaW5hdGVkQXJyYXkgPSBkYXlzQXJyYXkubWFwKFxuLy8gICAgICAgKGRheSkgPT5cbi8vICAgICAgICAgKDEgL1xuLy8gICAgICAgICAgICgxICsgTWF0aC5leHAoLXVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSAqIChkYXkgLSB0b3RhbERheXMgLyAyKSkpKSAqXG4vLyAgICAgICAgIHVudmFjY2luYXRlZFBvcHVsYXRpb25cbi8vICAgICApO1xuXG4vLyAgICAgY29uc3QgaW5mZWN0ZWRBcnJheSA9IGRheXNBcnJheS5tYXAoXG4vLyAgICAgICAoZGF5KSA9PlxuLy8gICAgICAgICBNYXRoLmV4cCgtaW5mZWN0aW9uUHJvYmFiaWxpdHkgKiAoZGF5IC0gcGVha0luZmVjdGlvbkRheSkgKiogMikgKlxuLy8gICAgICAgICBwb3B1bGF0aW9uU2l6ZVxuLy8gICAgICk7XG5cbi8vICAgICBjb25zdCByZWNvdmVyZWRBcnJheSA9IHJlY292ZXJlZFZhY2NpbmF0ZWRBcnJheS5tYXAoXG4vLyAgICAgICAocnYsIGkpID0+IHJ2ICsgcmVjb3ZlcmVkVW52YWNjaW5hdGVkQXJyYXlbaV1cbi8vICAgICApO1xuXG4vLyAgICAgY29uc3Qgc3VzY2VwdGlibGVBcnJheSA9IGRheXNBcnJheS5tYXAoKF8sIGkpID0+IHtcbi8vICAgICAgIGNvbnN0IHN1c2NlcHRpYmxlVmFsdWUgPVxuLy8gICAgICAgICBwb3B1bGF0aW9uU2l6ZSAtIChpbmZlY3RlZEFycmF5W2ldICsgcmVjb3ZlcmVkQXJyYXlbaV0pO1xuLy8gICAgICAgcmV0dXJuIE1hdGgubWF4KHN1c2NlcHRpYmxlVmFsdWUsIDApOyAvLyBFbnN1cmUgbm8gbmVnYXRpdmUgdmFsdWVzXG4vLyAgICAgfSk7XG5cbi8vICAgICAvLyBTZXQgY2FsY3VsYXRlZCBzdGF0ZSB2YXJpYWJsZXNcbi8vICAgICBzZXRTdXNjZXB0aWJsZVBvcHVsYXRpb24oc3VzY2VwdGlibGVBcnJheSk7XG4vLyAgICAgc2V0SW5mZWN0ZWRQb3B1bGF0aW9uKGluZmVjdGVkQXJyYXkpO1xuLy8gICAgIHNldFJlY292ZXJlZFZhY2NpbmF0ZWQocmVjb3ZlcmVkVmFjY2luYXRlZEFycmF5KTtcbi8vICAgICBzZXRSZWNvdmVyZWRVbnZhY2NpbmF0ZWQocmVjb3ZlcmVkVW52YWNjaW5hdGVkQXJyYXkpO1xuLy8gICAgIHNldFRvdGFsUmVjb3ZlcmVkUG9wdWxhdGlvbihyZWNvdmVyZWRBcnJheSk7XG4vLyAgIH0sIFtcbi8vICAgICBpbmZlY3Rpb25Qcm9iYWJpbGl0eSxcbi8vICAgICB2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlLFxuLy8gICAgIHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSxcbi8vICAgICBwb3B1bGF0aW9uVmFjY2luYXRlZCxcbi8vICAgICBwZWFrSW5mZWN0aW9uRGF5LFxuLy8gICAgIHRvdGFsRGF5cyxcbi8vICAgICBwb3B1bGF0aW9uU2l6ZSxcbi8vICAgXSk7XG5cbi8vICAgLy8gVXBkYXRlIGNoYXJ0IGRhdGEgd2hlbiBzdGF0ZSBjaGFuZ2VzXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XG4vLyAgICAgc2V0Q2hhcnREYXRhKHtcbi8vICAgICAgIGxhYmVsczogZGF5cyxcbi8vICAgICAgIGRhdGFzZXRzOiBbXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICBsYWJlbDogXCJTdXNjZXB0aWJsZVwiLFxuLy8gICAgICAgICAgIGRhdGE6IHN1c2NlcHRpYmxlUG9wdWxhdGlvbixcbi8vICAgICAgICAgICBib3JkZXJDb2xvcjogXCJvcmFuZ2VcIixcbi8vICAgICAgICAgICBmaWxsOiBmYWxzZSxcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIGxhYmVsOiBcIkluZmVjdGVkXCIsXG4vLyAgICAgICAgICAgZGF0YTogaW5mZWN0ZWRQb3B1bGF0aW9uLFxuLy8gICAgICAgICAgIGJvcmRlckNvbG9yOiBcInJlZFwiLFxuLy8gICAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgbGFiZWw6IFwiVG90YWwgUmVjb3ZlcmVkXCIsXG4vLyAgICAgICAgICAgZGF0YTogdG90YWxSZWNvdmVyZWRQb3B1bGF0aW9uLFxuLy8gICAgICAgICAgIGJvcmRlckNvbG9yOiBcImdyZWVuXCIsXG4vLyAgICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICBsYWJlbDogXCJSZWNvdmVyZWQgVmFjY2luYXRlZFwiLFxuLy8gICAgICAgICAgIGRhdGE6IHJlY292ZXJlZFZhY2NpbmF0ZWQsXG4vLyAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiYmx1ZVwiLFxuLy8gICAgICAgICAgIGJvcmRlckRhc2g6IFs1LCA1XSxcbi8vICAgICAgICAgICBmaWxsOiBmYWxzZSxcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIGxhYmVsOiBcIlJlY292ZXJlZCBVbnZhY2NpbmF0ZWRcIixcbi8vICAgICAgICAgICBkYXRhOiByZWNvdmVyZWRVbnZhY2NpbmF0ZWQsXG4vLyAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwicHVycGxlXCIsXG4vLyAgICAgICAgICAgYm9yZGVyRGFzaDogWzUsIDVdLFxuLy8gICAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgXSxcbi8vICAgICB9KTtcbi8vICAgfSwgW1xuLy8gICAgIGRheXMsXG4vLyAgICAgc3VzY2VwdGlibGVQb3B1bGF0aW9uLFxuLy8gICAgIGluZmVjdGVkUG9wdWxhdGlvbixcbi8vICAgICB0b3RhbFJlY292ZXJlZFBvcHVsYXRpb24sXG4vLyAgICAgcmVjb3ZlcmVkVmFjY2luYXRlZCxcbi8vICAgICByZWNvdmVyZWRVbnZhY2NpbmF0ZWQsXG4vLyAgIF0pO1xuXG4vLyAgIC8vIHA1LmpzIHNldHVwIGFuZCBkcmF3IGZ1bmN0aW9uc1xuLy8gICBjb25zdCBzZXR1cCA9IChwNTogYW55LCBjYW52YXNQYXJlbnRSZWY6IEVsZW1lbnQpID0+IHtcbi8vICAgICBwNS5jcmVhdGVDYW52YXMoODAwLCA2MDApLnBhcmVudChjYW52YXNQYXJlbnRSZWYpO1xuLy8gICAgIHA1SW5zdGFuY2UuY3VycmVudCA9IHA1O1xuLy8gICAgIHA1LmZyYW1lUmF0ZSgzMCk7XG4vLyAgIH07XG5cbi8vICAgY29uc3QgZHJhdyA9IChwNTogYW55KSA9PiB7XG4vLyAgICAgcDUuYmFja2dyb3VuZCgyNTUpO1xuLy8gICB9O1xuXG4vLyAgIC8vIEhhbmRsZSBzcGVlZCBjaGFuZ2VzIHVzaW5nIHA1J3MgZnJhbWVSYXRlKClcbi8vICAgY29uc3QgaGFuZGxlU3BlZWRDaGFuZ2UgPSAoKSA9PiB7XG4vLyAgICAgaWYgKHNwZWVkID09PSAxKSB7XG4vLyAgICAgICBzZXRTcGVlZCgyKTtcbi8vICAgICAgIHA1SW5zdGFuY2UuY3VycmVudC5mcmFtZVJhdGUoNjApO1xuLy8gICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDIpIHtcbi8vICAgICAgIHNldFNwZWVkKDQpO1xuLy8gICAgICAgcDVJbnN0YW5jZS5jdXJyZW50LmZyYW1lUmF0ZSgxMjApO1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICBzZXRTcGVlZCgxKTtcbi8vICAgICAgIHA1SW5zdGFuY2UuY3VycmVudC5mcmFtZVJhdGUoMzApO1xuLy8gICAgIH1cbi8vICAgfTtcblxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGdhcDogXCIyMHB4XCIgfX0+XG4vLyAgICAgICB7LyogTGVmdDogU2ltdWxhdGlvbiAqL31cbi8vICAgICAgIDxkaXY+XG4vLyAgICAgICAgIDxoMj5GbHUgU2ltdWxhdGlvbjwvaDI+XG4vLyAgICAgICAgIDxwPlZhY2NpbmUgRWZmaWNhY3k6IHtNYXRoLnJvdW5kKHZhY2NpbmVFZmZpY2FjeSAqIDEwMCl9JTwvcD5cbi8vICAgICAgICAgPHA+UG9wdWxhdGlvbiBWYWNjaW5hdGVkOiB7TWF0aC5yb3VuZChwb3B1bGF0aW9uVmFjY2luYXRlZCAqIDEwMCl9JTwvcD5cbi8vICAgICAgICAgPHA+SW5mZWN0aW9uIFByb2JhYmlsaXR5OiB7TWF0aC5yb3VuZChpbmZlY3Rpb25Qcm9iYWJpbGl0eSAqIDEwMCl9JTwvcD5cbi8vICAgICAgICAgPHA+XG4vLyAgICAgICAgICAgVmFjY2luYXRlZCBSZWNvdmVyeSBSYXRlOiB7TWF0aC5yb3VuZCh2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlICogMTAwKX0lXG4vLyAgICAgICAgIDwvcD5cbi8vICAgICAgICAgPHA+XG4vLyAgICAgICAgICAgVW52YWNjaW5hdGVkIFJlY292ZXJ5IFJhdGU6e1wiIFwifVxuLy8gICAgICAgICAgIHtNYXRoLnJvdW5kKHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSAqIDEwMCl9JVxuLy8gICAgICAgICA8L3A+XG4vLyAgICAgICAgIDxwPlBlYWsgSW5mZWN0aW9uIERheToge3BlYWtJbmZlY3Rpb25EYXl9PC9wPlxuLy8gICAgICAgICA8cD5Ub3RhbCBEYXlzOiB7dG90YWxEYXlzfTwvcD5cbi8vICAgICAgICAgPHA+UG9wdWxhdGlvbiBTaXplOiB7cG9wdWxhdGlvblNpemV9PC9wPlxuXG4vLyAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU3BlZWRDaGFuZ2V9PlxuLy8gICAgICAgICAgIHtzcGVlZCA9PT0gMVxuLy8gICAgICAgICAgICAgPyBcIlNwZWVkIFVwICgyeClcIlxuLy8gICAgICAgICAgICAgOiBzcGVlZCA9PT0gMlxuLy8gICAgICAgICAgICAgPyBcIlNwZWVkIFVwICg0eClcIlxuLy8gICAgICAgICAgICAgOiBcIlJlc2V0IFNwZWVkICgxeClcIn1cbi8vICAgICAgICAgPC9idXR0b24+XG5cbi8vICAgICAgICAgPFNrZXRjaCBzZXR1cD17c2V0dXB9IGRyYXc9e2RyYXd9IC8+XG4vLyAgICAgICA8L2Rpdj5cblxuLy8gICAgICAgey8qIFJpZ2h0OiBMaW5lIEdyYXBoICovfVxuLy8gICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCI0MDBweFwiIH19PlxuLy8gICAgICAgICA8aDM+U3RhdHVzIE92ZXIgVGltZTwvaDM+XG4vLyAgICAgICAgIDxMaW5lIGRhdGE9e2NoYXJ0RGF0YX0gLz5cbi8vICAgICAgIDwvZGl2PlxuXG4vLyAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0U2hvd01vZGFsKHRydWUpfT5BZGQgTmV3PC9idXR0b24+XG5cbi8vICAgICAgIHsvKiBNb2RhbCBmb3IgYWRkaW5nIG5ldyBncmFwaCAqL31cbi8vICAgICAgIDxNb2RhbCBpc09wZW49e3Nob3dNb2RhbH0gb25SZXF1ZXN0Q2xvc2U9eygpID0+IHNldFNob3dNb2RhbChmYWxzZSl9PlxuLy8gICAgICAgICA8aDI+RW50ZXIgTmV3IFBhcmFtZXRlcnM8L2gyPlxuLy8gICAgICAgICA8UGFyYW1ldGVyRm9ybSBvblN1Ym1pdD17YWRkTmV3R3JhcGh9IGNsb3NlTW9kYWw9eygpID0+IHNldFNob3dNb2RhbChmYWxzZSl9IC8+XG4vLyAgICAgICA8L01vZGFsPlxuXG4vLyAgICAgICB7LyogRGlzcGxheSBhbGwgZ3JhcGhzICovfVxuLy8gICAgICAge2dyYXBocy5tYXAoKGdyYXBoLCBpbmRleCkgPT4gKFxuLy8gICAgICAgICA8ZGl2IGtleT17aW5kZXh9PlxuLy8gICAgICAgICAgIDxoMz5HcmFwaCB7aW5kZXggKyAxfTwvaDM+XG4vLyAgICAgICAgICAgPExpbmUgZGF0YT17Z3JhcGh9IC8+XG4vLyAgICAgICAgIDwvZGl2PlxuLy8gICAgICAgKSl9XG4vLyAgICAgPC9kaXY+XG4vLyAgICk7XG5cbi8vIH1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFwidXNlIGNsaWVudFwiO1xuXG4vLyBpbXBvcnQgeyB1c2VTZWFyY2hQYXJhbXMgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCI7XG4vLyBpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbi8vIGltcG9ydCBTaW11bGF0aW9uQ29udHJvbHMgZnJvbSBcIi4vY29tcG9uZW50cy9TaW11bGF0aW9uQ29udHJvbHNcIjtcbi8vIGltcG9ydCBQb3B1bGF0aW9uQ2FudmFzIGZyb20gXCIuL2NvbXBvbmVudHMvUG9wdWxhdGlvbkNhbnZhc1wiO1xuLy8gaW1wb3J0IFN0YXR1c0NoYXJ0IGZyb20gXCIuL2NvbXBvbmVudHMvU3RhdHVzQ2hhcnRcIjtcbi8vIGltcG9ydCBQZXJzb24gZnJvbSBcIi4vY29tcG9uZW50cy9QZXJzb25cIjtcblxuLy8gdHlwZSBDaGFydERhdGEgPSB7XG4vLyAgIGxhYmVsczogbnVtYmVyW107XG4vLyAgIGRhdGFzZXRzOiB7XG4vLyAgICAgbGFiZWw6IHN0cmluZztcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcbi8vICAgICBib3JkZXJDb2xvcjogc3RyaW5nO1xuLy8gICAgIGZpbGw6IGJvb2xlYW47XG4vLyAgIH1bXTtcbi8vIH07XG5cbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNpbXVsYXRpb24oKSB7XG4vLyAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZVNlYXJjaFBhcmFtcygpO1xuXG4vLyAgIGNvbnN0IHZhY2NpbmVFZmZpY2FjeSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInZhY2NpbmVFZmZpY2FjeVwiKSB8fCBcIjAuOFwiXG4vLyAgICk7XG4vLyAgIGNvbnN0IHBvcHVsYXRpb25WYWNjaW5hdGVkID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwicG9wdWxhdGlvblZhY2NpbmF0ZWRcIikgfHwgXCIwLjdcIlxuLy8gICApO1xuLy8gICBjb25zdCBpbmZlY3Rpb25Qcm9iYWJpbGl0eSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcImluZmVjdGlvblByb2JhYmlsaXR5XCIpIHx8IFwiMC41XCJcbi8vICAgKTtcbi8vICAgY29uc3QgdmFjY2luYXRlZFJlY292ZXJ5UmF0ZSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInZhY2NpbmF0ZWRSZWNvdmVyeVJhdGVcIikgfHwgXCIwLjVcIlxuLy8gICApO1xuLy8gICBjb25zdCB1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGUgPSBwYXJzZUZsb2F0KFxuLy8gICAgIHNlYXJjaFBhcmFtcy5nZXQoXCJ1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGVcIikgfHwgXCIwLjFcIlxuLy8gICApO1xuLy8gICBjb25zdCBwZWFrSW5mZWN0aW9uRGF5ID0gcGFyc2VJbnQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInBlYWtJbmZlY3Rpb25EYXlcIikgfHwgXCI1XCJcbi8vICAgKTtcbi8vICAgY29uc3QgdG90YWxEYXlzID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldChcInRvdGFsRGF5c1wiKSB8fCBcIjMwXCIpO1xuLy8gICBjb25zdCBwb3B1bGF0aW9uU2l6ZSA9IHBhcnNlSW50KHNlYXJjaFBhcmFtcy5nZXQoXCJwb3B1bGF0aW9uU2l6ZVwiKSB8fCBcIjI1MFwiKTtcblxuLy8gICBjb25zdCBbcGVvcGxlLCBzZXRQZW9wbGVdID0gdXNlU3RhdGU8UGVyc29uW10+KFtdKTtcbi8vICAgY29uc3QgW3NwZWVkLCBzZXRTcGVlZF0gPSB1c2VTdGF0ZSgxKTtcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPENoYXJ0RGF0YT4oe1xuLy8gICAgIGxhYmVsczogW10sXG4vLyAgICAgZGF0YXNldHM6IFtcbi8vICAgICAgIHsgbGFiZWw6IFwiSGVhbHRoeVwiLCBkYXRhOiBbXSwgYm9yZGVyQ29sb3I6IFwiYmx1ZVwiLCBmaWxsOiBmYWxzZSB9LFxuLy8gICAgICAgeyBsYWJlbDogXCJJbmZlY3RlZFwiLCBkYXRhOiBbXSwgYm9yZGVyQ29sb3I6IFwicmVkXCIsIGZpbGw6IGZhbHNlIH0sXG4vLyAgICAgICB7IGxhYmVsOiBcIlJlY292ZXJlZFwiLCBkYXRhOiBbXSwgYm9yZGVyQ29sb3I6IFwiZ3JlZW5cIiwgZmlsbDogZmFsc2UgfSxcbi8vICAgICBdLFxuLy8gICB9KTtcblxuLy8gICBjb25zdCB1cGRhdGVDaGFydERhdGEgPSAoXG4vLyAgICAgaGVhbHRoeTogbnVtYmVyLFxuLy8gICAgIGluZmVjdGVkOiBudW1iZXIsXG4vLyAgICAgcmVjb3ZlcmVkOiBudW1iZXIsXG4vLyAgICAgZnJhbWU6IG51bWJlclxuLy8gICApID0+IHtcbi8vICAgICBzZXRDaGFydERhdGEoKHByZXZEYXRhKSA9PiAoe1xuLy8gICAgICAgbGFiZWxzOiBbLi4ucHJldkRhdGEubGFiZWxzLCBmcmFtZV0sXG4vLyAgICAgICBkYXRhc2V0czogW1xuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgLi4ucHJldkRhdGEuZGF0YXNldHNbMF0sXG4vLyAgICAgICAgICAgZGF0YTogWy4uLnByZXZEYXRhLmRhdGFzZXRzWzBdLmRhdGEsIGhlYWx0aHldLFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgLi4ucHJldkRhdGEuZGF0YXNldHNbMV0sXG4vLyAgICAgICAgICAgZGF0YTogWy4uLnByZXZEYXRhLmRhdGFzZXRzWzFdLmRhdGEsIGluZmVjdGVkXSxcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIC4uLnByZXZEYXRhLmRhdGFzZXRzWzJdLFxuLy8gICAgICAgICAgIGRhdGE6IFsuLi5wcmV2RGF0YS5kYXRhc2V0c1syXS5kYXRhLCByZWNvdmVyZWRdLFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgXSxcbi8vICAgICB9KSk7XG4vLyAgIH07XG5cbi8vICAgY29uc3QgaGFuZGxlU3BlZWRDaGFuZ2UgPSAoKSA9PlxuLy8gICAgIHNldFNwZWVkKChwcmV2KSA9PiAocHJldiA9PT0gMSA/IDIgOiBwcmV2ID09PSAyID8gNCA6IDEpKTtcblxuLy8gICB1c2VFZmZlY3QoKCkgPT4ge1xuLy8gICAgIGNvbnN0IG5ld1Blb3BsZTogUGVyc29uW10gPSBbXTtcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvcHVsYXRpb25TaXplOyBpKyspIHtcbi8vICAgICAgIGNvbnN0IHggPSBNYXRoLnJhbmRvbSgpICogODAwO1xuLy8gICAgICAgY29uc3QgeSA9IE1hdGgucmFuZG9tKCkgKiA2MDA7XG4vLyAgICAgICBjb25zdCB2YWNjaW5hdGVkID0gTWF0aC5yYW5kb20oKSA8IHBvcHVsYXRpb25WYWNjaW5hdGVkO1xuLy8gICAgICAgbmV3UGVvcGxlLnB1c2gobmV3IFBlcnNvbih4LCB5LCB2YWNjaW5hdGVkKSk7XG4vLyAgICAgfVxuLy8gICAgIHNldFBlb3BsZShuZXdQZW9wbGUpO1xuLy8gICB9LCBbcG9wdWxhdGlvblNpemUsIHBvcHVsYXRpb25WYWNjaW5hdGVkXSk7XG5cbi8vICAgcmV0dXJuIChcbi8vICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBnYXA6IFwiMjBweFwiIH19PlxuLy8gICAgICAgPFNpbXVsYXRpb25Db250cm9sc1xuLy8gICAgICAgICB2YWNjaW5lRWZmaWNhY3k9e3ZhY2NpbmVFZmZpY2FjeX1cbi8vICAgICAgICAgcG9wdWxhdGlvblZhY2NpbmF0ZWQ9e3BvcHVsYXRpb25WYWNjaW5hdGVkfVxuLy8gICAgICAgICBpbmZlY3Rpb25Qcm9iYWJpbGl0eT17aW5mZWN0aW9uUHJvYmFiaWxpdHl9XG4vLyAgICAgICAgIHZhY2NpbmF0ZWRSZWNvdmVyeVJhdGU9e3ZhY2NpbmF0ZWRSZWNvdmVyeVJhdGV9XG4vLyAgICAgICAgIHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZT17dW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlfVxuLy8gICAgICAgICBwZWFrSW5mZWN0aW9uRGF5PXtwZWFrSW5mZWN0aW9uRGF5fVxuLy8gICAgICAgICB0b3RhbERheXM9e3RvdGFsRGF5c31cbi8vICAgICAgICAgcG9wdWxhdGlvblNpemU9e3BvcHVsYXRpb25TaXplfVxuLy8gICAgICAgICBzcGVlZD17c3BlZWR9XG4vLyAgICAgICAgIGhhbmRsZVNwZWVkQ2hhbmdlPXtoYW5kbGVTcGVlZENoYW5nZX1cbi8vICAgICAgIC8+XG4vLyAgICAgICA8UG9wdWxhdGlvbkNhbnZhc1xuLy8gICAgICAgICBwZW9wbGU9e3Blb3BsZX1cbi8vICAgICAgICAgdmFjY2luZUVmZmljYWN5PXt2YWNjaW5lRWZmaWNhY3l9XG4vLyAgICAgICAgIGluZmVjdGlvblByb2JhYmlsaXR5PXtpbmZlY3Rpb25Qcm9iYWJpbGl0eX1cbi8vICAgICAgICAgdmFjY2luYXRlZFJlY292ZXJ5UmF0ZT17dmFjY2luYXRlZFJlY292ZXJ5UmF0ZX1cbi8vICAgICAgICAgdW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlPXt1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGV9XG4vLyAgICAgICAgIHRvdGFsRGF5cz17dG90YWxEYXlzfVxuLy8gICAgICAgICB1cGRhdGVDaGFydERhdGE9e3VwZGF0ZUNoYXJ0RGF0YX1cbi8vICAgICAgIC8+XG4vLyAgICAgICA8U3RhdHVzQ2hhcnQgY2hhcnREYXRhPXtjaGFydERhdGF9IC8+XG4vLyAgICAgPC9kaXY+XG4vLyAgICk7XG4vLyB9XG5cbi8vLS0tLS0tLS0tXG5cblwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFNpbXVsYXRpb25Db250cm9scyBmcm9tIFwiLi9jb21wb25lbnRzL1NpbXVsYXRpb25Db250cm9sc1wiO1xuaW1wb3J0IFBvcHVsYXRpb25DYW52YXMgZnJvbSBcIi4vY29tcG9uZW50cy9Qb3B1bGF0aW9uQ2FudmFzXCI7XG5pbXBvcnQgU3RhdHVzQ2hhcnQgZnJvbSBcIi4vY29tcG9uZW50cy9TdGF0dXNDaGFydFwiO1xuaW1wb3J0IFNpbXVsYXRpb25Db250cm9sc1BvcCBmcm9tIFwiLi9jb21wb25lbnRzL1NpbXVsYXRpb25Db250cm9sc1BvcG92ZXJcIjtcbmltcG9ydCBQZXJzb24gZnJvbSBcIi4vY29tcG9uZW50cy9QZXJzb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2ltdWxhdGlvbigpIHtcbiAgLy8gU3RhdGUgdG8gbWFuYWdlIGxpc3Qgb2Ygc2ltdWxhdGlvbnNcbiAgY29uc3QgW3NpbXVsYXRpb25zLCBzZXRTaW11bGF0aW9uc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pO1xuXG4gIC8vIEZ1bmN0aW9uIHRvIGFkZCBhIG5ldyBzaW11bGF0aW9uXG4gIGNvbnN0IGFkZFNpbXVsYXRpb24gPSAocGFyYW1zOiBhbnkpID0+IHtcbiAgICBjb25zdCBuZXdQZW9wbGU6IFBlcnNvbltdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMucG9wdWxhdGlvblNpemU7IGkrKykge1xuICAgICAgY29uc3QgeCA9IE1hdGgucmFuZG9tKCkgKiA4MDA7XG4gICAgICBjb25zdCB5ID0gTWF0aC5yYW5kb20oKSAqIDYwMDtcbiAgICAgIGNvbnN0IHZhY2NpbmF0ZWQgPSBNYXRoLnJhbmRvbSgpIDwgcGFyYW1zLnBvcHVsYXRpb25WYWNjaW5hdGVkO1xuICAgICAgbmV3UGVvcGxlLnB1c2gobmV3IFBlcnNvbih4LCB5LCB2YWNjaW5hdGVkKSk7XG4gICAgfVxuXG4gICAgLy8gQ2hhcnQgRGF0YSBJbml0aWFsIFN0YXRlXG4gICAgY29uc3QgaW5pdGlhbENoYXJ0RGF0YSA9IHtcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBkYXRhc2V0czogW1xuICAgICAgICB7IGxhYmVsOiBcIkhlYWx0aHlcIiwgZGF0YTogW10sIGJvcmRlckNvbG9yOiBcImJsdWVcIiwgZmlsbDogZmFsc2UgfSxcbiAgICAgICAgeyBsYWJlbDogXCJJbmZlY3RlZFwiLCBkYXRhOiBbXSwgYm9yZGVyQ29sb3I6IFwicmVkXCIsIGZpbGw6IGZhbHNlIH0sXG4gICAgICAgIHsgbGFiZWw6IFwiUmVjb3ZlcmVkXCIsIGRhdGE6IFtdLCBib3JkZXJDb2xvcjogXCJncmVlblwiLCBmaWxsOiBmYWxzZSB9LFxuICAgICAgXSxcbiAgICB9O1xuXG4gICAgc2V0U2ltdWxhdGlvbnMoKHByZXZTaW11bGF0aW9ucykgPT4gW1xuICAgICAgLi4ucHJldlNpbXVsYXRpb25zLFxuICAgICAge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHBlb3BsZTogbmV3UGVvcGxlLFxuICAgICAgICBjaGFydERhdGE6IGluaXRpYWxDaGFydERhdGEsXG4gICAgICB9LFxuICAgIF0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiBcImZsZXhcIiwgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIiwgZ2FwOiBcIjIwcHhcIiwgcGFkZGluZzogXCIyMHB4XCIgfX0+XG4gICAgICB7LyogUG9wb3ZlciBCdXR0b24gU2VjdGlvbiAqL31cbiAgICAgIDxkaXYgc3R5bGU9e3sgYWxpZ25TZWxmOiBcImNlbnRlclwiLCBtYXJnaW5Ub3A6IFwiMjBweFwiIH19PlxuICAgICAgICA8U2ltdWxhdGlvbkNvbnRyb2xzUG9wIGFkZFNpbXVsYXRpb249e2FkZFNpbXVsYXRpb259IC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIExpc3Qgb2YgU2ltdWxhdGlvbnMgKi99XG4gICAgICB7c2ltdWxhdGlvbnMubWFwKChzaW11bGF0aW9uLCBpbmRleCkgPT4gKFxuICAgICAgICA8ZGl2IGtleT17aW5kZXh9IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBnYXA6IFwiMjBweFwiLCBtYXJnaW5Cb3R0b206IFwiNDBweFwiIH19PlxuICAgICAgICAgIHsvKiBMZWZ0IFNlY3Rpb246IENvbnRyb2xzIGFuZCBDYW52YXMgKi99XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgIGdhcDogXCIyMHB4XCIsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxTaW11bGF0aW9uQ29udHJvbHMgey4uLnNpbXVsYXRpb24ucGFyYW1zfSBzcGVlZD17MX0gaGFuZGxlU3BlZWRDaGFuZ2U9eygpID0+IHt9fSAvPlxuICAgICAgICAgICAgPFBvcHVsYXRpb25DYW52YXNcbiAgICAgICAgICAgICAgcGVvcGxlPXtzaW11bGF0aW9uLnBlb3BsZX1cbiAgICAgICAgICAgICAgdmFjY2luZUVmZmljYWN5PXtzaW11bGF0aW9uLnBhcmFtcy52YWNjaW5lRWZmaWNhY3l9XG4gICAgICAgICAgICAgIGluZmVjdGlvblByb2JhYmlsaXR5PXtzaW11bGF0aW9uLnBhcmFtcy5pbmZlY3Rpb25Qcm9iYWJpbGl0eX1cbiAgICAgICAgICAgICAgdmFjY2luYXRlZFJlY292ZXJ5UmF0ZT17c2ltdWxhdGlvbi5wYXJhbXMudmFjY2luYXRlZFJlY292ZXJ5UmF0ZX1cbiAgICAgICAgICAgICAgdW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlPXtzaW11bGF0aW9uLnBhcmFtcy51bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGV9XG4gICAgICAgICAgICAgIHRvdGFsRGF5cz17c2ltdWxhdGlvbi5wYXJhbXMudG90YWxEYXlzfVxuICAgICAgICAgICAgICB1cGRhdGVDaGFydERhdGE9eyhoZWFsdGh5LCBpbmZlY3RlZCwgcmVjb3ZlcmVkLCBmcmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFNpbXVsYXRpb25zKChwcmV2U2ltdWxhdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTaW11bGF0aW9ucyA9IFsuLi5wcmV2U2ltdWxhdGlvbnNdO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlZFNpbXVsYXRpb25zW2luZGV4XS5jaGFydERhdGEubGFiZWxzLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlZFNpbXVsYXRpb25zW2luZGV4XS5jaGFydERhdGEuZGF0YXNldHNbMF0uZGF0YS5wdXNoKGhlYWx0aHkpO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlZFNpbXVsYXRpb25zW2luZGV4XS5jaGFydERhdGEuZGF0YXNldHNbMV0uZGF0YS5wdXNoKGluZmVjdGVkKTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRTaW11bGF0aW9uc1tpbmRleF0uY2hhcnREYXRhLmRhdGFzZXRzWzJdLmRhdGEucHVzaChyZWNvdmVyZWQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRTaW11bGF0aW9ucztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7LyogUmlnaHQgU2VjdGlvbjogU3RhdHVzIENoYXJ0ICovfVxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleDogMSB9fT5cbiAgICAgICAgICAgIDxTdGF0dXNDaGFydCBjaGFydERhdGE9e3NpbXVsYXRpb24uY2hhcnREYXRhfSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkpfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJTaW11bGF0aW9uQ29udHJvbHMiLCJQb3B1bGF0aW9uQ2FudmFzIiwiU3RhdHVzQ2hhcnQiLCJTaW11bGF0aW9uQ29udHJvbHNQb3AiLCJQZXJzb24iLCJTaW11bGF0aW9uIiwic2ltdWxhdGlvbnMiLCJzZXRTaW11bGF0aW9ucyIsImFkZFNpbXVsYXRpb24iLCJwYXJhbXMiLCJuZXdQZW9wbGUiLCJpIiwicG9wdWxhdGlvblNpemUiLCJ4IiwiTWF0aCIsInJhbmRvbSIsInkiLCJ2YWNjaW5hdGVkIiwicG9wdWxhdGlvblZhY2NpbmF0ZWQiLCJwdXNoIiwiaW5pdGlhbENoYXJ0RGF0YSIsImxhYmVscyIsImRhdGFzZXRzIiwibGFiZWwiLCJkYXRhIiwiYm9yZGVyQ29sb3IiLCJmaWxsIiwicHJldlNpbXVsYXRpb25zIiwicGVvcGxlIiwiY2hhcnREYXRhIiwiZGl2Iiwic3R5bGUiLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsImdhcCIsInBhZGRpbmciLCJhbGlnblNlbGYiLCJtYXJnaW5Ub3AiLCJtYXAiLCJzaW11bGF0aW9uIiwiaW5kZXgiLCJtYXJnaW5Cb3R0b20iLCJmbGV4Iiwic3BlZWQiLCJoYW5kbGVTcGVlZENoYW5nZSIsInZhY2NpbmVFZmZpY2FjeSIsImluZmVjdGlvblByb2JhYmlsaXR5IiwidmFjY2luYXRlZFJlY292ZXJ5UmF0ZSIsInVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSIsInRvdGFsRGF5cyIsInVwZGF0ZUNoYXJ0RGF0YSIsImhlYWx0aHkiLCJpbmZlY3RlZCIsInJlY292ZXJlZCIsImZyYW1lIiwidXBkYXRlZFNpbXVsYXRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/simulation/page.tsx\n"));

/***/ })

});