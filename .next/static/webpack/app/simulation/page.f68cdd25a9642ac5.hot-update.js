"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/simulation/page",{

/***/ "(app-pages-browser)/./src/app/simulation/page.tsx":
/*!*************************************!*\
  !*** ./src/app/simulation/page.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Simulation; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@14.2.13_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_SimulationControls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/SimulationControls */ \"(app-pages-browser)/./src/app/simulation/components/SimulationControls.tsx\");\n/* harmony import */ var _components_PopulationCanvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/PopulationCanvas */ \"(app-pages-browser)/./src/app/simulation/components/PopulationCanvas.tsx\");\n/* harmony import */ var _components_StatusChart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/StatusChart */ \"(app-pages-browser)/./src/app/simulation/components/StatusChart.tsx\");\n/* harmony import */ var _components_SimulationControlsPopover__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/SimulationControlsPopover */ \"(app-pages-browser)/./src/app/simulation/components/SimulationControlsPopover.tsx\");\n/* harmony import */ var _components_Person__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/Person */ \"(app-pages-browser)/./src/app/simulation/components/Person.ts\");\n// \"use client\";\n// import { useSearchParams } from \"next/navigation\";\n// import dynamic from \"next/dynamic\";\n// import { useEffect, useRef, useState } from \"react\";\n// import { Line } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   LineElement,\n//   CategoryScale,\n//   LinearScale,\n//   PointElement,\n// } from \"chart.js\";\n// // Dynamically load react-p5 since p5.js relies on browser-specific features\n// const Sketch = dynamic(() => import(\"react-p5\").then((mod) => mod.default), {\n//   ssr: false,\n// });\n// // Register Chart.js components\n// ChartJS.register(LineElement, CategoryScale, LinearScale, PointElement);\n// // Define chart data type\n// type ChartData = {\n//   labels: number[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     borderColor: string;\n//     fill: boolean;\n//   }[];\n// };\n// export default function Simulation() {\n//   const searchParams = useSearchParams();\n//   const vaccineEfficacy = parseFloat(\n//     searchParams.get(\"vaccineEfficacy\") || \"0.8\"\n//   );\n//   const populationVaccinated = parseFloat(\n//     searchParams.get(\"populationVaccinated\") || \"0.7\"\n//   );\n//   const infectionProbability = parseFloat(\n//     searchParams.get(\"infectionProbability\") || \"0.5\"\n//   );\n//   const vaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"vaccinatedRecoveryRate\") || \"0.5\"\n//   );\n//   const unvaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"unvaccinatedRecoveryRate\") || \"0.1\"\n//   );\n//   const peakInfectionDay = parseInt(\n//     searchParams.get(\"peakInfectionDay\") || \"5\"\n//   );\n//   const totalDays = parseInt(searchParams.get(\"totalDays\") || \"30\");\n//   const populationSize = parseInt(searchParams.get(\"populationSize\") || \"250\");\n//   // Population array managed outside of React state for performance\n//   const [people, setPeople] = useState<Person[]>([]);\n//   //const populationSize = 100;\n//   const p5Instance = useRef<any>(null); // Reference to p5.js instance\n//   // Simulation speed control\n//   const [speed, setSpeed] = useState(1); // 1x speed by default\n//   // Chart data\n//   const [chartData, setChartData] = useState<ChartData>({\n//     labels: [], // Frame count (or time steps)\n//     datasets: [\n//       {\n//         label: \"Healthy\",\n//         data: [],\n//         borderColor: \"blue\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Infected\",\n//         data: [],\n//         borderColor: \"red\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Recovered\",\n//         data: [],\n//         borderColor: \"green\",\n//         fill: false,\n//       },\n//     ],\n//   });\n//   const frameCount = useRef(0); // Keep track of the simulation frames\n//   // Person object representing each individual in the population\n//   class Person {\n//     x: number;\n//     y: number;\n//     status: string; // 'healthy', 'infected', 'recovered'\n//     vaccinated: boolean;\n//     constructor(x: number, y: number, vaccinated: boolean, status = \"healthy\") {\n//       this.x = x;\n//       this.y = y;\n//       this.vaccinated = vaccinated;\n//       this.status = status;\n//     }\n//     // Determine if a person can get infected\n//     tryToInfect(p5: any, infectionRadius: number) {\n//       if (this.status === \"healthy\") {\n//         for (let other of people) {\n//           if (other.status === \"infected\") {\n//             // Check if this person is within infection radius\n//             let d = p5.dist(this.x, this.y, other.x, other.y);\n//             if (d < infectionRadius) {\n//               // Check vaccination status and infection probability\n//               if (!this.vaccinated || Math.random() > vaccineEfficacy) {\n//                 // Random chance of infection\n//                 if (Math.random() < infectionProbability) {\n//                   this.status = \"infected\"; // This person gets infected\n//                 }\n//               }\n//             }\n//           }\n//         }\n//       }\n//     }\n//     move(p5: any) {\n//       this.x += p5.random(-5, 5); // Increased movement\n//       this.y += p5.random(-5, 5);\n//       this.x = p5.constrain(this.x, 0, p5.width);\n//       this.y = p5.constrain(this.y, 0, p5.height);\n//     }\n//     show(p5: any) {\n//       if (this.status === \"healthy\") {\n//         p5.fill(100, 200, 255); // blue for healthy\n//       } else if (this.status === \"infected\") {\n//         p5.fill(255, 100, 100); // red for infected\n//       } else if (this.status === \"recovered\") {\n//         p5.fill(0, 255, 0); // green for recovered\n//       }\n//       p5.ellipse(this.x, this.y, 20, 20);\n//     }\n//     // recover() {\n//     //   if (this.status === \"infected\" && Math.random() < 0.01) {\n//     //     this.status = \"recovered\";\n//     //   }\n//     // }\n//     // new recover function needed\n//     recover() {\n//       if (this.status === \"infected\") {\n//         const recoveryChance = this.vaccinated\n//           ? vaccinatedRecoveryRate\n//           : unvaccinatedRecoveryRate;\n//         if (Math.random() < recoveryChance) {\n//           this.status = \"recovered\";\n//         }\n//       }\n//     }\n//   }\n//   // Initialize population once in useEffect\n//   useEffect(() => {\n//     if (people.length === 0) {\n//       const newPeople: Person[] = [];\n//       for (let i = 0; i < populationSize; i++) {\n//         let x = Math.random() * 800;\n//         let y = Math.random() * 600;\n//         let vaccinated = Math.random() < populationVaccinated;\n//         newPeople.push(new Person(x, y, vaccinated));\n//       }\n//       for (let i = 0; i < 50; i++) {\n//         newPeople[i].status = \"infected\"; // setting to infected from start\n//       }\n//       setPeople(newPeople);\n//     }\n//   }, []); // Empty dependency array ensures people are initialized only once\n//   // Function to update chart data\n//   const updateChartData = (\n//     healthy: number,\n//     infected: number,\n//     recovered: number,\n//     frame: number\n//   ) => {\n//     setChartData((prevData) => ({\n//       labels: [...prevData.labels, frame], // Append the new frame count\n//       datasets: [\n//         {\n//           ...prevData.datasets[0],\n//           data: [...prevData.datasets[0].data, healthy], // Append the new healthy count\n//         },\n//         {\n//           ...prevData.datasets[1],\n//           data: [...prevData.datasets[1].data, infected], // Append the new infected count\n//         },\n//         {\n//           ...prevData.datasets[2],\n//           data: [...prevData.datasets[2].data, recovered], // Append the new recovered count\n//         },\n//       ],\n//     }));\n//   };\n//   // p5.js setup and draw functions\n//   const setup = (p5: any, canvasParentRef: Element) => {\n//     p5.createCanvas(800, 600).parent(canvasParentRef);\n//     p5Instance.current = p5; // Save p5.js instance for future reference\n//     p5.frameRate(30); // Set default frame rate\n//   };\n//   const draw = (p5: any) => {\n//     p5.background(255);\n//     let healthyCount = 0;\n//     let infectedCount = 0;\n//     let recoveredCount = 0;\n//     // Render and update each person\n//     people.forEach((person) => {\n//       person.move(p5);\n//       person.show(p5);\n//       person.tryToInfect(p5, 50); // Infection radius is 50 pixels\n//       person.recover();\n//       // Count people by their status\n//       if (person.status === \"healthy\") healthyCount++;\n//       if (person.status === \"infected\") infectedCount++;\n//       if (person.status === \"recovered\") recoveredCount++;\n//     });\n//     if (frameCount.current > totalDays * 30) {\n//       p5.noLoop();\n//     }\n//     // Update the chart every frame\n//     frameCount.current++;\n//     updateChartData(\n//       healthyCount,\n//       infectedCount,\n//       recoveredCount,\n//       frameCount.current\n//     );\n//   };\n//   // Handle speed changes using p5's frameRate()\n//   const handleSpeedChange = () => {\n//     if (speed === 1) {\n//       setSpeed(2); // Speed up to 2x\n//       p5Instance.current.frameRate(60); // Double the frame rate for 2x speed\n//     } else if (speed === 2) {\n//       setSpeed(4); // Speed up to 4x\n//       p5Instance.current.frameRate(120); // Quadruple the frame rate for 4x speed\n//     } else {\n//       setSpeed(1); // Reset to 1x speed\n//       p5Instance.current.frameRate(30); // Default frame rate\n//     }\n//   };\n//   return (\n//     <div style={{ display: \"flex\", gap: \"20px\" }}>\n//       {/* Left: Simulation */}\n//       <div>\n//         <h2>Flu Simulation</h2>\n//         <p>Vaccine Efficacy: {Math.round(vaccineEfficacy * 100)}%</p>\n//         <p>Population Vaccinated: {Math.round(populationVaccinated * 100)}%</p>\n//         <p>Infection Probability: {Math.round(infectionProbability * 100)}%</p>\n//         <p>\n//           {\" \"}\n//           Vaccinated Recovery Rate: {Math.round(vaccinatedRecoveryRate * 100)}%\n//         </p>\n//         <p>\n//           Unvaccinated Recovery Rate:{\" \"}\n//           {Math.round(unvaccinatedRecoveryRate * 100)}%\n//         </p>\n//         <p>Peak Infection Day: {peakInfectionDay}</p>\n//         <p>Total Days: {totalDays}</p>\n//         <p>Population Size: {populationSize}</p>\n//         <button onClick={handleSpeedChange}>\n//           {speed === 1\n//             ? \"Speed Up (2x)\"\n//             : speed === 2\n//             ? \"Speed Up (4x)\"\n//             : \"Reset Speed (1x)\"}\n//         </button>\n//         <Sketch setup={setup} draw={draw} />\n//       </div>\n//       {/* Right: Line Graph */}\n//       <div style={{ width: \"400px\" }}>\n//         <h3>Status Over Time</h3>\n//         <Line data={chartData} />\n//       </div>\n//     </div>\n//   );\n// }\n//---------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------\n//---------------------------------------------------------------------------------------\n// \"use client\";\n// import { useSearchParams } from \"next/navigation\";\n// import dynamic from \"next/dynamic\";\n// import { useEffect, useRef, useState } from \"react\";\n// import { Line } from \"react-chartjs-2\";\n// import {\n//   Chart as ChartJS,\n//   LineElement,\n//   CategoryScale,\n//   LinearScale,\n//   PointElement,\n// } from \"chart.js\";\n// import Modal from 'react-modal';\n// // Dynamically load react-p5 since p5.js relies on browser-specific features\n// const Sketch = dynamic(() => import(\"react-p5\").then((mod) => mod.default), {\n//   ssr: false,\n// });\n// // Register Chart.js components\n// ChartJS.register(LineElement, CategoryScale, LinearScale, PointElement);\n// // Define chart data type\n// type ChartData = {\n//   labels: number[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     borderColor: string;\n//     fill: boolean;\n//     borderDash?: number[];\n//   }[];\n// };\n// export default function Simulation() {\n//   const [showModal, setShowModal] = useState(false);\n//   const [graphs, setGraphs] = useState([]);\n//   const searchParams = useSearchParams();\n//   const addNewGraph = (newParams)=> {\n//     const newGraphData = runSimulation(newParams);\n//     setGraphs([...graphs, newGraphData]);\n//     setShowModal(false);\n//   }\n//   // Extract parameters from URL\n//   const vaccineEfficacy = parseFloat(\n//     searchParams.get(\"vaccineEfficacy\") || \"0.8\"\n//   );\n//   const populationVaccinated = parseFloat(\n//     searchParams.get(\"populationVaccinated\") || \"0.7\"\n//   );\n//   const infectionProbability = parseFloat(\n//     searchParams.get(\"infectionProbability\") || \"0.5\"\n//   );\n//   const vaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"vaccinatedRecoveryRate\") || \"0.5\"\n//   );\n//   const unvaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"unvaccinatedRecoveryRate\") || \"0.1\"\n//   );\n//   const peakInfectionDay = parseInt(\n//     searchParams.get(\"peakInfectionDay\") || \"5\"\n//   );\n//   const totalDays = parseInt(searchParams.get(\"totalDays\") || \"30\");\n//   const populationSize = parseInt(searchParams.get(\"populationSize\") || \"100\");\n//   // State for simulation data\n//   const [days, setDays] = useState<number[]>([]);\n//   const [susceptiblePopulation, setSusceptiblePopulation] = useState<number[]>(\n//     []\n//   );\n//   const [infectedPopulation, setInfectedPopulation] = useState<number[]>([]);\n//   const [recoveredVaccinated, setRecoveredVaccinated] = useState<number[]>([]);\n//   const [recoveredUnvaccinated, setRecoveredUnvaccinated] = useState<number[]>(\n//     []\n//   );\n//   const [totalRecoveredPopulation, setTotalRecoveredPopulation] = useState<\n//     number[]\n//   >([]);\n//   const [speed, setSpeed] = useState(1); // 1x speed by default\n//   const p5Instance = useRef<any>(null); // Reference to p5.js instance\n//   // Chart data\n//   const [chartData, setChartData] = useState<ChartData>({\n//     labels: [], // Frame count (or time steps)\n//     datasets: [\n//       {\n//         label: \"Susceptible\",\n//         data: [],\n//         borderColor: \"orange\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Infected\",\n//         data: [],\n//         borderColor: \"red\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Total Recovered\",\n//         data: [],\n//         borderColor: \"green\",\n//         fill: false,\n//       },\n//       {\n//         label: \"Recovered Vaccinated\",\n//         data: [],\n//         borderColor: \"blue\",\n//         borderDash: [5, 5],\n//         fill: false,\n//       },\n//       {\n//         label: \"Recovered Unvaccinated\",\n//         data: [],\n//         borderColor: \"purple\",\n//         borderDash: [5, 5],\n//         fill: false,\n//       },\n//     ],\n//   });\n//   // Initialize and calculate flu model data\n//   useEffect(() => {\n//     const daysArray = Array.from(\n//       { length: 100 },\n//       (_, i) => (i / 100) * totalDays\n//     );\n//     setDays(daysArray);\n//     const vaccinatedPopulation = populationSize * populationVaccinated;\n//     const unvaccinatedPopulation = populationSize * (1 - populationVaccinated);\n//     // Calculate recovered population\n//     const recoveredVaccinatedArray = daysArray.map(\n//       (day) =>\n//         (1 / (1 + Math.exp(-vaccinatedRecoveryRate * (day - totalDays / 2)))) *\n//         vaccinatedPopulation\n//     );\n//     const recoveredUnvaccinatedArray = daysArray.map(\n//       (day) =>\n//         (1 /\n//           (1 + Math.exp(-unvaccinatedRecoveryRate * (day - totalDays / 2)))) *\n//         unvaccinatedPopulation\n//     );\n//     const infectedArray = daysArray.map(\n//       (day) =>\n//         Math.exp(-infectionProbability * (day - peakInfectionDay) ** 2) *\n//         populationSize\n//     );\n//     const recoveredArray = recoveredVaccinatedArray.map(\n//       (rv, i) => rv + recoveredUnvaccinatedArray[i]\n//     );\n//     const susceptibleArray = daysArray.map((_, i) => {\n//       const susceptibleValue =\n//         populationSize - (infectedArray[i] + recoveredArray[i]);\n//       return Math.max(susceptibleValue, 0); // Ensure no negative values\n//     });\n//     // Set calculated state variables\n//     setSusceptiblePopulation(susceptibleArray);\n//     setInfectedPopulation(infectedArray);\n//     setRecoveredVaccinated(recoveredVaccinatedArray);\n//     setRecoveredUnvaccinated(recoveredUnvaccinatedArray);\n//     setTotalRecoveredPopulation(recoveredArray);\n//   }, [\n//     infectionProbability,\n//     vaccinatedRecoveryRate,\n//     unvaccinatedRecoveryRate,\n//     populationVaccinated,\n//     peakInfectionDay,\n//     totalDays,\n//     populationSize,\n//   ]);\n//   // Update chart data when state changes\n//   useEffect(() => {\n//     setChartData({\n//       labels: days,\n//       datasets: [\n//         {\n//           label: \"Susceptible\",\n//           data: susceptiblePopulation,\n//           borderColor: \"orange\",\n//           fill: false,\n//         },\n//         {\n//           label: \"Infected\",\n//           data: infectedPopulation,\n//           borderColor: \"red\",\n//           fill: false,\n//         },\n//         {\n//           label: \"Total Recovered\",\n//           data: totalRecoveredPopulation,\n//           borderColor: \"green\",\n//           fill: false,\n//         },\n//         {\n//           label: \"Recovered Vaccinated\",\n//           data: recoveredVaccinated,\n//           borderColor: \"blue\",\n//           borderDash: [5, 5],\n//           fill: false,\n//         },\n//         {\n//           label: \"Recovered Unvaccinated\",\n//           data: recoveredUnvaccinated,\n//           borderColor: \"purple\",\n//           borderDash: [5, 5],\n//           fill: false,\n//         },\n//       ],\n//     });\n//   }, [\n//     days,\n//     susceptiblePopulation,\n//     infectedPopulation,\n//     totalRecoveredPopulation,\n//     recoveredVaccinated,\n//     recoveredUnvaccinated,\n//   ]);\n//   // p5.js setup and draw functions\n//   const setup = (p5: any, canvasParentRef: Element) => {\n//     p5.createCanvas(800, 600).parent(canvasParentRef);\n//     p5Instance.current = p5;\n//     p5.frameRate(30);\n//   };\n//   const draw = (p5: any) => {\n//     p5.background(255);\n//   };\n//   // Handle speed changes using p5's frameRate()\n//   const handleSpeedChange = () => {\n//     if (speed === 1) {\n//       setSpeed(2);\n//       p5Instance.current.frameRate(60);\n//     } else if (speed === 2) {\n//       setSpeed(4);\n//       p5Instance.current.frameRate(120);\n//     } else {\n//       setSpeed(1);\n//       p5Instance.current.frameRate(30);\n//     }\n//   };\n//   return (\n//     <div style={{ display: \"flex\", gap: \"20px\" }}>\n//       {/* Left: Simulation */}\n//       <div>\n//         <h2>Flu Simulation</h2>\n//         <p>Vaccine Efficacy: {Math.round(vaccineEfficacy * 100)}%</p>\n//         <p>Population Vaccinated: {Math.round(populationVaccinated * 100)}%</p>\n//         <p>Infection Probability: {Math.round(infectionProbability * 100)}%</p>\n//         <p>\n//           Vaccinated Recovery Rate: {Math.round(vaccinatedRecoveryRate * 100)}%\n//         </p>\n//         <p>\n//           Unvaccinated Recovery Rate:{\" \"}\n//           {Math.round(unvaccinatedRecoveryRate * 100)}%\n//         </p>\n//         <p>Peak Infection Day: {peakInfectionDay}</p>\n//         <p>Total Days: {totalDays}</p>\n//         <p>Population Size: {populationSize}</p>\n//         <button onClick={handleSpeedChange}>\n//           {speed === 1\n//             ? \"Speed Up (2x)\"\n//             : speed === 2\n//             ? \"Speed Up (4x)\"\n//             : \"Reset Speed (1x)\"}\n//         </button>\n//         <Sketch setup={setup} draw={draw} />\n//       </div>\n//       {/* Right: Line Graph */}\n//       <div style={{ width: \"400px\" }}>\n//         <h3>Status Over Time</h3>\n//         <Line data={chartData} />\n//       </div>\n//   <button onClick={() => setShowModal(true)}>Add New</button>\n//       {/* Modal for adding new graph */}\n//       <Modal isOpen={showModal} onRequestClose={() => setShowModal(false)}>\n//         <h2>Enter New Parameters</h2>\n//         <ParameterForm onSubmit={addNewGraph} closeModal={() => setShowModal(false)} />\n//       </Modal>\n//       {/* Display all graphs */}\n//       {graphs.map((graph, index) => (\n//         <div key={index}>\n//           <h3>Graph {index + 1}</h3>\n//           <Line data={graph} />\n//         </div>\n//       ))}\n//     </div>\n//   );\n// }\n//------------------------------------------------\n//------------------------------------------------\n// \"use client\";\n// import { useSearchParams } from \"next/navigation\";\n// import { useEffect, useState, useRef } from \"react\";\n// import SimulationControls from \"./components/SimulationControls\";\n// import PopulationCanvas from \"./components/PopulationCanvas\";\n// import StatusChart from \"./components/StatusChart\";\n// import Person from \"./components/Person\";\n// type ChartData = {\n//   labels: number[];\n//   datasets: {\n//     label: string;\n//     data: number[];\n//     borderColor: string;\n//     fill: boolean;\n//   }[];\n// };\n// export default function Simulation() {\n//   const searchParams = useSearchParams();\n//   const vaccineEfficacy = parseFloat(\n//     searchParams.get(\"vaccineEfficacy\") || \"0.8\"\n//   );\n//   const populationVaccinated = parseFloat(\n//     searchParams.get(\"populationVaccinated\") || \"0.7\"\n//   );\n//   const infectionProbability = parseFloat(\n//     searchParams.get(\"infectionProbability\") || \"0.5\"\n//   );\n//   const vaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"vaccinatedRecoveryRate\") || \"0.5\"\n//   );\n//   const unvaccinatedRecoveryRate = parseFloat(\n//     searchParams.get(\"unvaccinatedRecoveryRate\") || \"0.1\"\n//   );\n//   const peakInfectionDay = parseInt(\n//     searchParams.get(\"peakInfectionDay\") || \"5\"\n//   );\n//   const totalDays = parseInt(searchParams.get(\"totalDays\") || \"30\");\n//   const populationSize = parseInt(searchParams.get(\"populationSize\") || \"250\");\n//   const [people, setPeople] = useState<Person[]>([]);\n//   const [speed, setSpeed] = useState(1);\n//   const [chartData, setChartData] = useState<ChartData>({\n//     labels: [],\n//     datasets: [\n//       { label: \"Healthy\", data: [], borderColor: \"blue\", fill: false },\n//       { label: \"Infected\", data: [], borderColor: \"red\", fill: false },\n//       { label: \"Recovered\", data: [], borderColor: \"green\", fill: false },\n//     ],\n//   });\n//   const updateChartData = (\n//     healthy: number,\n//     infected: number,\n//     recovered: number,\n//     frame: number\n//   ) => {\n//     setChartData((prevData) => ({\n//       labels: [...prevData.labels, frame],\n//       datasets: [\n//         {\n//           ...prevData.datasets[0],\n//           data: [...prevData.datasets[0].data, healthy],\n//         },\n//         {\n//           ...prevData.datasets[1],\n//           data: [...prevData.datasets[1].data, infected],\n//         },\n//         {\n//           ...prevData.datasets[2],\n//           data: [...prevData.datasets[2].data, recovered],\n//         },\n//       ],\n//     }));\n//   };\n//   const handleSpeedChange = () =>\n//     setSpeed((prev) => (prev === 1 ? 2 : prev === 2 ? 4 : 1));\n//   useEffect(() => {\n//     const newPeople: Person[] = [];\n//     for (let i = 0; i < populationSize; i++) {\n//       const x = Math.random() * 800;\n//       const y = Math.random() * 600;\n//       const vaccinated = Math.random() < populationVaccinated;\n//       newPeople.push(new Person(x, y, vaccinated));\n//     }\n//     setPeople(newPeople);\n//   }, [populationSize, populationVaccinated]);\n//   return (\n//     <div style={{ display: \"flex\", gap: \"20px\" }}>\n//       <SimulationControls\n//         vaccineEfficacy={vaccineEfficacy}\n//         populationVaccinated={populationVaccinated}\n//         infectionProbability={infectionProbability}\n//         vaccinatedRecoveryRate={vaccinatedRecoveryRate}\n//         unvaccinatedRecoveryRate={unvaccinatedRecoveryRate}\n//         peakInfectionDay={peakInfectionDay}\n//         totalDays={totalDays}\n//         populationSize={populationSize}\n//         speed={speed}\n//         handleSpeedChange={handleSpeedChange}\n//       />\n//       <PopulationCanvas\n//         people={people}\n//         vaccineEfficacy={vaccineEfficacy}\n//         infectionProbability={infectionProbability}\n//         vaccinatedRecoveryRate={vaccinatedRecoveryRate}\n//         unvaccinatedRecoveryRate={unvaccinatedRecoveryRate}\n//         totalDays={totalDays}\n//         updateChartData={updateChartData}\n//       />\n//       <StatusChart chartData={chartData} />\n//     </div>\n//   );\n// }\n//---------\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nfunction Simulation() {\n    _s();\n    const searchParams = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useSearchParams)();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    // State to manage list of simulations\n    const [simulations, setSimulations] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    // Parameter retrieval function\n    const getSimulationParams = ()=>{\n        return {\n            vaccineEfficacy: parseFloat(searchParams.get(\"vaccineEfficacy\") || \"0.8\"),\n            populationVaccinated: parseFloat(searchParams.get(\"populationVaccinated\") || \"0.7\"),\n            infectionProbability: parseFloat(searchParams.get(\"infectionProbability\") || \"0.5\"),\n            vaccinatedRecoveryRate: parseFloat(searchParams.get(\"vaccinatedRecoveryRate\") || \"0.5\"),\n            unvaccinatedRecoveryRate: parseFloat(searchParams.get(\"unvaccinatedRecoveryRate\") || \"0.1\"),\n            peakInfectionDay: parseInt(searchParams.get(\"peakInfectionDay\") || \"5\"),\n            totalDays: parseInt(searchParams.get(\"totalDays\") || \"30\"),\n            populationSize: parseInt(searchParams.get(\"populationSize\") || \"250\")\n        };\n    };\n    // Function to add a new simulation\n    const addSimulation = ()=>{\n        const params = getSimulationParams();\n        const newPeople = [];\n        for(let i = 0; i < params.populationSize; i++){\n            const x = Math.random() * 800;\n            const y = Math.random() * 600;\n            const vaccinated = Math.random() < params.populationVaccinated;\n            newPeople.push(new _components_Person__WEBPACK_IMPORTED_MODULE_7__[\"default\"](x, y, vaccinated));\n        }\n        // Chart Data Initial State\n        const initialChartData = {\n            labels: [],\n            datasets: [\n                {\n                    label: \"Healthy\",\n                    data: [],\n                    borderColor: \"blue\",\n                    fill: false\n                },\n                {\n                    label: \"Infected\",\n                    data: [],\n                    borderColor: \"red\",\n                    fill: false\n                },\n                {\n                    label: \"Recovered\",\n                    data: [],\n                    borderColor: \"green\",\n                    fill: false\n                }\n            ]\n        };\n        setSimulations((prevSimulations)=>[\n                ...prevSimulations,\n                {\n                    params,\n                    people: newPeople,\n                    chartData: initialChartData,\n                    currentDay: 0\n                }\n            ]);\n    };\n    // Function to update chart data\n    const updateChartData = (simulationIndex, healthy, infected, recovered, frame)=>{\n        setSimulations((prevSimulations)=>{\n            const updatedSimulations = [\n                ...prevSimulations\n            ];\n            updatedSimulations[simulationIndex].chartData.labels.push(frame);\n            updatedSimulations[simulationIndex].chartData.datasets[0].data.push(healthy);\n            updatedSimulations[simulationIndex].chartData.datasets[1].data.push(infected);\n            updatedSimulations[simulationIndex].chartData.datasets[2].data.push(recovered);\n            return updatedSimulations;\n        });\n    };\n    // Effect to initialize the simulation and update it over time\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        // Create an interval to simulate the spread and update the charts\n        const interval = setInterval(()=>{\n            setSimulations((prevSimulations)=>prevSimulations.map((simulation, index)=>{\n                    const { currentDay, params, people } = simulation;\n                    // Stop updating if the simulation has reached its total days\n                    if (currentDay >= params.totalDays) {\n                        return simulation;\n                    }\n                    // Simulate the disease spread and recovery\n                    let healthy = 0, infected = 0, recovered = 0;\n                    // Update people status\n                    people.forEach((person)=>{\n                        person.updateStatus(params.infectionProbability, params.vaccineEfficacy, params.vaccinatedRecoveryRate, params.unvaccinatedRecoveryRate);\n                        if (person.isHealthy()) healthy++;\n                        else if (person.isInfected()) infected++;\n                        else if (person.isRecovered()) recovered++;\n                    });\n                    // Update chart data\n                    updateChartData(index, healthy, infected, recovered, currentDay);\n                    // Increment current day\n                    return {\n                        ...simulation,\n                        currentDay: currentDay + 1,\n                        people\n                    };\n                }));\n        }, 1000); // Run every second for the sake of simulation\n        return ()=>clearInterval(interval);\n    }, [\n        simulations\n    ]);\n    // Function to handle updating URL parameters\n    const updateUrlParams = (newParams)=>{\n        const query = new URLSearchParams();\n        Object.entries(newParams).forEach((param)=>{\n            let [key, value] = param;\n            if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n                query.set(key, value.toString());\n            }\n        });\n        router.push(\"?\".concat(query.toString()));\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            gap: \"20px\",\n            padding: \"20px\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    alignSelf: \"center\",\n                    marginTop: \"20px\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SimulationControlsPopover__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                    addSimulation: addSimulation,\n                    updateUrlParams: updateUrlParams\n                }, void 0, false, {\n                    fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                    lineNumber: 891,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                lineNumber: 890,\n                columnNumber: 7\n            }, this),\n            simulations.map((simulation, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        display: \"flex\",\n                        gap: \"20px\",\n                        marginBottom: \"40px\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                flex: 1,\n                                display: \"flex\",\n                                flexDirection: \"column\",\n                                gap: \"20px\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SimulationControls__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    ...simulation.params,\n                                    speed: 1,\n                                    handleSpeedChange: ()=>{}\n                                }, void 0, false, {\n                                    fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                                    lineNumber: 909,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_PopulationCanvas__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                    people: simulation.people,\n                                    vaccineEfficacy: simulation.params.vaccineEfficacy,\n                                    infectionProbability: simulation.params.infectionProbability,\n                                    vaccinatedRecoveryRate: simulation.params.vaccinatedRecoveryRate,\n                                    unvaccinatedRecoveryRate: simulation.params.unvaccinatedRecoveryRate,\n                                    totalDays: simulation.params.totalDays,\n                                    updateChartData: (healthy, infected, recovered, frame)=>{\n                                        updateChartData(index, healthy, infected, recovered, frame);\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                                    lineNumber: 910,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                            lineNumber: 901,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                flex: 1\n                            },\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_StatusChart__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                chartData: simulation.chartData\n                            }, void 0, false, {\n                                fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                                lineNumber: 925,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                            lineNumber: 924,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, index, true, {\n                    fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n                    lineNumber: 899,\n                    columnNumber: 9\n                }, this))\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/lukabagashvili/Desktop/FluFlighters/src/app/simulation/page.tsx\",\n        lineNumber: 888,\n        columnNumber: 5\n    }, this);\n}\n_s(Simulation, \"BRD7In95MFX431n32RIT4Eap08s=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.useSearchParams,\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter\n    ];\n});\n_c = Simulation;\nvar _c;\n$RefreshReg$(_c, \"Simulation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvc2ltdWxhdGlvbi9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUEsZ0JBQWdCO0FBRWhCLHFEQUFxRDtBQUNyRCxzQ0FBc0M7QUFDdEMsdURBQXVEO0FBQ3ZELDBDQUEwQztBQUMxQyxXQUFXO0FBQ1gsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFFckIsK0VBQStFO0FBQy9FLGdGQUFnRjtBQUNoRixnQkFBZ0I7QUFDaEIsTUFBTTtBQUNOLGtDQUFrQztBQUNsQywyRUFBMkU7QUFFM0UsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1QsS0FBSztBQUVMLHlDQUF5QztBQUN6Qyw0Q0FBNEM7QUFFNUMsd0NBQXdDO0FBQ3hDLG1EQUFtRDtBQUNuRCxPQUFPO0FBQ1AsNkNBQTZDO0FBQzdDLHdEQUF3RDtBQUN4RCxPQUFPO0FBQ1AsNkNBQTZDO0FBQzdDLHdEQUF3RDtBQUN4RCxPQUFPO0FBRVAsK0NBQStDO0FBQy9DLDBEQUEwRDtBQUMxRCxPQUFPO0FBRVAsaURBQWlEO0FBQ2pELDREQUE0RDtBQUM1RCxPQUFPO0FBRVAsdUNBQXVDO0FBQ3ZDLGtEQUFrRDtBQUNsRCxPQUFPO0FBRVAsdUVBQXVFO0FBRXZFLGtGQUFrRjtBQUVsRix1RUFBdUU7QUFDdkUsd0RBQXdEO0FBQ3hELGtDQUFrQztBQUNsQyx5RUFBeUU7QUFFekUsZ0NBQWdDO0FBQ2hDLGtFQUFrRTtBQUVsRSxrQkFBa0I7QUFDbEIsNERBQTREO0FBQzVELGlEQUFpRDtBQUNqRCxrQkFBa0I7QUFDbEIsVUFBVTtBQUNWLDRCQUE0QjtBQUM1QixvQkFBb0I7QUFDcEIsK0JBQStCO0FBQy9C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OUIsTUFBTSxDQUFDTix3QkFBd0I7b0NBQ3BFRyxXQUFXaUMsV0FBVzlCLE1BQU0sQ0FBQ0gsU0FBUztvQ0FDdEN1QixpQkFBaUIsQ0FBQ0UsU0FBU0MsVUFBVUMsV0FBV0M7d0NBQzlDTCxnQkFBZ0JXLE9BQU9ULFNBQVNDLFVBQVVDLFdBQVdDO29DQUN2RDs7Ozs7Ozs7Ozs7O3NDQUtKLDhEQUFDd0I7NEJBQUlDLE9BQU87Z0NBQUVRLE1BQU07NEJBQUU7c0NBQ3BCLDRFQUFDL0UsK0RBQVdBO2dDQUFDdUMsV0FBV1ksV0FBV1osU0FBUzs7Ozs7Ozs7Ozs7O21CQTFCdENhOzs7Ozs7Ozs7OztBQWdDbEI7R0E5S3dCakQ7O1FBQ0RULDREQUFlQTtRQUNyQkMsc0RBQVNBOzs7S0FGRlEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9zaW11bGF0aW9uL3BhZ2UudHN4P2EzNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gXCJ1c2UgY2xpZW50XCI7XG5cbi8vIGltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbi8vIGltcG9ydCBkeW5hbWljIGZyb20gXCJuZXh0L2R5bmFtaWNcIjtcbi8vIGltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuLy8gaW1wb3J0IHsgTGluZSB9IGZyb20gXCJyZWFjdC1jaGFydGpzLTJcIjtcbi8vIGltcG9ydCB7XG4vLyAgIENoYXJ0IGFzIENoYXJ0SlMsXG4vLyAgIExpbmVFbGVtZW50LFxuLy8gICBDYXRlZ29yeVNjYWxlLFxuLy8gICBMaW5lYXJTY2FsZSxcbi8vICAgUG9pbnRFbGVtZW50LFxuLy8gfSBmcm9tIFwiY2hhcnQuanNcIjtcblxuLy8gLy8gRHluYW1pY2FsbHkgbG9hZCByZWFjdC1wNSBzaW5jZSBwNS5qcyByZWxpZXMgb24gYnJvd3Nlci1zcGVjaWZpYyBmZWF0dXJlc1xuLy8gY29uc3QgU2tldGNoID0gZHluYW1pYygoKSA9PiBpbXBvcnQoXCJyZWFjdC1wNVwiKS50aGVuKChtb2QpID0+IG1vZC5kZWZhdWx0KSwge1xuLy8gICBzc3I6IGZhbHNlLFxuLy8gfSk7XG4vLyAvLyBSZWdpc3RlciBDaGFydC5qcyBjb21wb25lbnRzXG4vLyBDaGFydEpTLnJlZ2lzdGVyKExpbmVFbGVtZW50LCBDYXRlZ29yeVNjYWxlLCBMaW5lYXJTY2FsZSwgUG9pbnRFbGVtZW50KTtcblxuLy8gLy8gRGVmaW5lIGNoYXJ0IGRhdGEgdHlwZVxuLy8gdHlwZSBDaGFydERhdGEgPSB7XG4vLyAgIGxhYmVsczogbnVtYmVyW107XG4vLyAgIGRhdGFzZXRzOiB7XG4vLyAgICAgbGFiZWw6IHN0cmluZztcbi8vICAgICBkYXRhOiBudW1iZXJbXTtcbi8vICAgICBib3JkZXJDb2xvcjogc3RyaW5nO1xuLy8gICAgIGZpbGw6IGJvb2xlYW47XG4vLyAgIH1bXTtcbi8vIH07XG5cbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNpbXVsYXRpb24oKSB7XG4vLyAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHVzZVNlYXJjaFBhcmFtcygpO1xuXG4vLyAgIGNvbnN0IHZhY2NpbmVFZmZpY2FjeSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInZhY2NpbmVFZmZpY2FjeVwiKSB8fCBcIjAuOFwiXG4vLyAgICk7XG4vLyAgIGNvbnN0IHBvcHVsYXRpb25WYWNjaW5hdGVkID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwicG9wdWxhdGlvblZhY2NpbmF0ZWRcIikgfHwgXCIwLjdcIlxuLy8gICApO1xuLy8gICBjb25zdCBpbmZlY3Rpb25Qcm9iYWJpbGl0eSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcImluZmVjdGlvblByb2JhYmlsaXR5XCIpIHx8IFwiMC41XCJcbi8vICAgKTtcblxuLy8gICBjb25zdCB2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwidmFjY2luYXRlZFJlY292ZXJ5UmF0ZVwiKSB8fCBcIjAuNVwiXG4vLyAgICk7XG5cbi8vICAgY29uc3QgdW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwidW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlXCIpIHx8IFwiMC4xXCJcbi8vICAgKTtcblxuLy8gICBjb25zdCBwZWFrSW5mZWN0aW9uRGF5ID0gcGFyc2VJbnQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInBlYWtJbmZlY3Rpb25EYXlcIikgfHwgXCI1XCJcbi8vICAgKTtcblxuLy8gICBjb25zdCB0b3RhbERheXMgPSBwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KFwidG90YWxEYXlzXCIpIHx8IFwiMzBcIik7XG5cbi8vICAgY29uc3QgcG9wdWxhdGlvblNpemUgPSBwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KFwicG9wdWxhdGlvblNpemVcIikgfHwgXCIyNTBcIik7XG5cbi8vICAgLy8gUG9wdWxhdGlvbiBhcnJheSBtYW5hZ2VkIG91dHNpZGUgb2YgUmVhY3Qgc3RhdGUgZm9yIHBlcmZvcm1hbmNlXG4vLyAgIGNvbnN0IFtwZW9wbGUsIHNldFBlb3BsZV0gPSB1c2VTdGF0ZTxQZXJzb25bXT4oW10pO1xuLy8gICAvL2NvbnN0IHBvcHVsYXRpb25TaXplID0gMTAwO1xuLy8gICBjb25zdCBwNUluc3RhbmNlID0gdXNlUmVmPGFueT4obnVsbCk7IC8vIFJlZmVyZW5jZSB0byBwNS5qcyBpbnN0YW5jZVxuXG4vLyAgIC8vIFNpbXVsYXRpb24gc3BlZWQgY29udHJvbFxuLy8gICBjb25zdCBbc3BlZWQsIHNldFNwZWVkXSA9IHVzZVN0YXRlKDEpOyAvLyAxeCBzcGVlZCBieSBkZWZhdWx0XG5cbi8vICAgLy8gQ2hhcnQgZGF0YVxuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8Q2hhcnREYXRhPih7XG4vLyAgICAgbGFiZWxzOiBbXSwgLy8gRnJhbWUgY291bnQgKG9yIHRpbWUgc3RlcHMpXG4vLyAgICAgZGF0YXNldHM6IFtcbi8vICAgICAgIHtcbi8vICAgICAgICAgbGFiZWw6IFwiSGVhbHRoeVwiLFxuLy8gICAgICAgICBkYXRhOiBbXSxcbi8vICAgICAgICAgYm9yZGVyQ29sb3I6IFwiYmx1ZVwiLFxuLy8gICAgICAgICBmaWxsOiBmYWxzZSxcbi8vICAgICAgIH0sXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGxhYmVsOiBcIkluZmVjdGVkXCIsXG4vLyAgICAgICAgIGRhdGE6IFtdLFxuLy8gICAgICAgICBib3JkZXJDb2xvcjogXCJyZWRcIixcbi8vICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICB9LFxuLy8gICAgICAge1xuLy8gICAgICAgICBsYWJlbDogXCJSZWNvdmVyZWRcIixcbi8vICAgICAgICAgZGF0YTogW10sXG4vLyAgICAgICAgIGJvcmRlckNvbG9yOiBcImdyZWVuXCIsXG4vLyAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgfSxcbi8vICAgICBdLFxuLy8gICB9KTtcbi8vICAgY29uc3QgZnJhbWVDb3VudCA9IHVzZVJlZigwKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgc2ltdWxhdGlvbiBmcmFtZXNcblxuLy8gICAvLyBQZXJzb24gb2JqZWN0IHJlcHJlc2VudGluZyBlYWNoIGluZGl2aWR1YWwgaW4gdGhlIHBvcHVsYXRpb25cbi8vICAgY2xhc3MgUGVyc29uIHtcbi8vICAgICB4OiBudW1iZXI7XG4vLyAgICAgeTogbnVtYmVyO1xuLy8gICAgIHN0YXR1czogc3RyaW5nOyAvLyAnaGVhbHRoeScsICdpbmZlY3RlZCcsICdyZWNvdmVyZWQnXG4vLyAgICAgdmFjY2luYXRlZDogYm9vbGVhbjtcblxuLy8gICAgIGNvbnN0cnVjdG9yKHg6IG51bWJlciwgeTogbnVtYmVyLCB2YWNjaW5hdGVkOiBib29sZWFuLCBzdGF0dXMgPSBcImhlYWx0aHlcIikge1xuLy8gICAgICAgdGhpcy54ID0geDtcbi8vICAgICAgIHRoaXMueSA9IHk7XG4vLyAgICAgICB0aGlzLnZhY2NpbmF0ZWQgPSB2YWNjaW5hdGVkO1xuLy8gICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4vLyAgICAgfVxuXG4vLyAgICAgLy8gRGV0ZXJtaW5lIGlmIGEgcGVyc29uIGNhbiBnZXQgaW5mZWN0ZWRcbi8vICAgICB0cnlUb0luZmVjdChwNTogYW55LCBpbmZlY3Rpb25SYWRpdXM6IG51bWJlcikge1xuLy8gICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImhlYWx0aHlcIikge1xuLy8gICAgICAgICBmb3IgKGxldCBvdGhlciBvZiBwZW9wbGUpIHtcbi8vICAgICAgICAgICBpZiAob3RoZXIuc3RhdHVzID09PSBcImluZmVjdGVkXCIpIHtcbi8vICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcGVyc29uIGlzIHdpdGhpbiBpbmZlY3Rpb24gcmFkaXVzXG4vLyAgICAgICAgICAgICBsZXQgZCA9IHA1LmRpc3QodGhpcy54LCB0aGlzLnksIG90aGVyLngsIG90aGVyLnkpO1xuLy8gICAgICAgICAgICAgaWYgKGQgPCBpbmZlY3Rpb25SYWRpdXMpIHtcbi8vICAgICAgICAgICAgICAgLy8gQ2hlY2sgdmFjY2luYXRpb24gc3RhdHVzIGFuZCBpbmZlY3Rpb24gcHJvYmFiaWxpdHlcbi8vICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhY2NpbmF0ZWQgfHwgTWF0aC5yYW5kb20oKSA+IHZhY2NpbmVFZmZpY2FjeSkge1xuLy8gICAgICAgICAgICAgICAgIC8vIFJhbmRvbSBjaGFuY2Ugb2YgaW5mZWN0aW9uXG4vLyAgICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCBpbmZlY3Rpb25Qcm9iYWJpbGl0eSkge1xuLy8gICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBcImluZmVjdGVkXCI7IC8vIFRoaXMgcGVyc29uIGdldHMgaW5mZWN0ZWRcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9XG5cbi8vICAgICBtb3ZlKHA1OiBhbnkpIHtcbi8vICAgICAgIHRoaXMueCArPSBwNS5yYW5kb20oLTUsIDUpOyAvLyBJbmNyZWFzZWQgbW92ZW1lbnRcbi8vICAgICAgIHRoaXMueSArPSBwNS5yYW5kb20oLTUsIDUpO1xuLy8gICAgICAgdGhpcy54ID0gcDUuY29uc3RyYWluKHRoaXMueCwgMCwgcDUud2lkdGgpO1xuLy8gICAgICAgdGhpcy55ID0gcDUuY29uc3RyYWluKHRoaXMueSwgMCwgcDUuaGVpZ2h0KTtcbi8vICAgICB9XG5cbi8vICAgICBzaG93KHA1OiBhbnkpIHtcbi8vICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJoZWFsdGh5XCIpIHtcbi8vICAgICAgICAgcDUuZmlsbCgxMDAsIDIwMCwgMjU1KTsgLy8gYmx1ZSBmb3IgaGVhbHRoeVxuLy8gICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJpbmZlY3RlZFwiKSB7XG4vLyAgICAgICAgIHA1LmZpbGwoMjU1LCAxMDAsIDEwMCk7IC8vIHJlZCBmb3IgaW5mZWN0ZWRcbi8vICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IFwicmVjb3ZlcmVkXCIpIHtcbi8vICAgICAgICAgcDUuZmlsbCgwLCAyNTUsIDApOyAvLyBncmVlbiBmb3IgcmVjb3ZlcmVkXG4vLyAgICAgICB9XG4vLyAgICAgICBwNS5lbGxpcHNlKHRoaXMueCwgdGhpcy55LCAyMCwgMjApO1xuLy8gICAgIH1cblxuLy8gICAgIC8vIHJlY292ZXIoKSB7XG4vLyAgICAgLy8gICBpZiAodGhpcy5zdGF0dXMgPT09IFwiaW5mZWN0ZWRcIiAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wMSkge1xuLy8gICAgIC8vICAgICB0aGlzLnN0YXR1cyA9IFwicmVjb3ZlcmVkXCI7XG4vLyAgICAgLy8gICB9XG4vLyAgICAgLy8gfVxuLy8gICAgIC8vIG5ldyByZWNvdmVyIGZ1bmN0aW9uIG5lZWRlZFxuXG4vLyAgICAgcmVjb3ZlcigpIHtcbi8vICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJpbmZlY3RlZFwiKSB7XG4vLyAgICAgICAgIGNvbnN0IHJlY292ZXJ5Q2hhbmNlID0gdGhpcy52YWNjaW5hdGVkXG4vLyAgICAgICAgICAgPyB2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlXG4vLyAgICAgICAgICAgOiB1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGU7XG4vLyAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgcmVjb3ZlcnlDaGFuY2UpIHtcbi8vICAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVjb3ZlcmVkXCI7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gICAvLyBJbml0aWFsaXplIHBvcHVsYXRpb24gb25jZSBpbiB1c2VFZmZlY3Rcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcbi8vICAgICBpZiAocGVvcGxlLmxlbmd0aCA9PT0gMCkge1xuLy8gICAgICAgY29uc3QgbmV3UGVvcGxlOiBQZXJzb25bXSA9IFtdO1xuLy8gICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3B1bGF0aW9uU2l6ZTsgaSsrKSB7XG4vLyAgICAgICAgIGxldCB4ID0gTWF0aC5yYW5kb20oKSAqIDgwMDtcbi8vICAgICAgICAgbGV0IHkgPSBNYXRoLnJhbmRvbSgpICogNjAwO1xuLy8gICAgICAgICBsZXQgdmFjY2luYXRlZCA9IE1hdGgucmFuZG9tKCkgPCBwb3B1bGF0aW9uVmFjY2luYXRlZDtcbi8vICAgICAgICAgbmV3UGVvcGxlLnB1c2gobmV3IFBlcnNvbih4LCB5LCB2YWNjaW5hdGVkKSk7XG4vLyAgICAgICB9XG4vLyAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyBpKyspIHtcbi8vICAgICAgICAgbmV3UGVvcGxlW2ldLnN0YXR1cyA9IFwiaW5mZWN0ZWRcIjsgLy8gc2V0dGluZyB0byBpbmZlY3RlZCBmcm9tIHN0YXJ0XG4vLyAgICAgICB9XG4vLyAgICAgICBzZXRQZW9wbGUobmV3UGVvcGxlKTtcbi8vICAgICB9XG4vLyAgIH0sIFtdKTsgLy8gRW1wdHkgZGVwZW5kZW5jeSBhcnJheSBlbnN1cmVzIHBlb3BsZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlXG5cbi8vICAgLy8gRnVuY3Rpb24gdG8gdXBkYXRlIGNoYXJ0IGRhdGFcbi8vICAgY29uc3QgdXBkYXRlQ2hhcnREYXRhID0gKFxuLy8gICAgIGhlYWx0aHk6IG51bWJlcixcbi8vICAgICBpbmZlY3RlZDogbnVtYmVyLFxuLy8gICAgIHJlY292ZXJlZDogbnVtYmVyLFxuLy8gICAgIGZyYW1lOiBudW1iZXJcbi8vICAgKSA9PiB7XG4vLyAgICAgc2V0Q2hhcnREYXRhKChwcmV2RGF0YSkgPT4gKHtcbi8vICAgICAgIGxhYmVsczogWy4uLnByZXZEYXRhLmxhYmVscywgZnJhbWVdLCAvLyBBcHBlbmQgdGhlIG5ldyBmcmFtZSBjb3VudFxuLy8gICAgICAgZGF0YXNldHM6IFtcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIC4uLnByZXZEYXRhLmRhdGFzZXRzWzBdLFxuLy8gICAgICAgICAgIGRhdGE6IFsuLi5wcmV2RGF0YS5kYXRhc2V0c1swXS5kYXRhLCBoZWFsdGh5XSwgLy8gQXBwZW5kIHRoZSBuZXcgaGVhbHRoeSBjb3VudFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgLi4ucHJldkRhdGEuZGF0YXNldHNbMV0sXG4vLyAgICAgICAgICAgZGF0YTogWy4uLnByZXZEYXRhLmRhdGFzZXRzWzFdLmRhdGEsIGluZmVjdGVkXSwgLy8gQXBwZW5kIHRoZSBuZXcgaW5mZWN0ZWQgY291bnRcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIC4uLnByZXZEYXRhLmRhdGFzZXRzWzJdLFxuLy8gICAgICAgICAgIGRhdGE6IFsuLi5wcmV2RGF0YS5kYXRhc2V0c1syXS5kYXRhLCByZWNvdmVyZWRdLCAvLyBBcHBlbmQgdGhlIG5ldyByZWNvdmVyZWQgY291bnRcbi8vICAgICAgICAgfSxcbi8vICAgICAgIF0sXG4vLyAgICAgfSkpO1xuLy8gICB9O1xuXG4vLyAgIC8vIHA1LmpzIHNldHVwIGFuZCBkcmF3IGZ1bmN0aW9uc1xuLy8gICBjb25zdCBzZXR1cCA9IChwNTogYW55LCBjYW52YXNQYXJlbnRSZWY6IEVsZW1lbnQpID0+IHtcbi8vICAgICBwNS5jcmVhdGVDYW52YXMoODAwLCA2MDApLnBhcmVudChjYW52YXNQYXJlbnRSZWYpO1xuLy8gICAgIHA1SW5zdGFuY2UuY3VycmVudCA9IHA1OyAvLyBTYXZlIHA1LmpzIGluc3RhbmNlIGZvciBmdXR1cmUgcmVmZXJlbmNlXG4vLyAgICAgcDUuZnJhbWVSYXRlKDMwKTsgLy8gU2V0IGRlZmF1bHQgZnJhbWUgcmF0ZVxuLy8gICB9O1xuXG4vLyAgIGNvbnN0IGRyYXcgPSAocDU6IGFueSkgPT4ge1xuLy8gICAgIHA1LmJhY2tncm91bmQoMjU1KTtcblxuLy8gICAgIGxldCBoZWFsdGh5Q291bnQgPSAwO1xuLy8gICAgIGxldCBpbmZlY3RlZENvdW50ID0gMDtcbi8vICAgICBsZXQgcmVjb3ZlcmVkQ291bnQgPSAwO1xuXG4vLyAgICAgLy8gUmVuZGVyIGFuZCB1cGRhdGUgZWFjaCBwZXJzb25cbi8vICAgICBwZW9wbGUuZm9yRWFjaCgocGVyc29uKSA9PiB7XG4vLyAgICAgICBwZXJzb24ubW92ZShwNSk7XG4vLyAgICAgICBwZXJzb24uc2hvdyhwNSk7XG4vLyAgICAgICBwZXJzb24udHJ5VG9JbmZlY3QocDUsIDUwKTsgLy8gSW5mZWN0aW9uIHJhZGl1cyBpcyA1MCBwaXhlbHNcbi8vICAgICAgIHBlcnNvbi5yZWNvdmVyKCk7XG5cbi8vICAgICAgIC8vIENvdW50IHBlb3BsZSBieSB0aGVpciBzdGF0dXNcbi8vICAgICAgIGlmIChwZXJzb24uc3RhdHVzID09PSBcImhlYWx0aHlcIikgaGVhbHRoeUNvdW50Kys7XG4vLyAgICAgICBpZiAocGVyc29uLnN0YXR1cyA9PT0gXCJpbmZlY3RlZFwiKSBpbmZlY3RlZENvdW50Kys7XG4vLyAgICAgICBpZiAocGVyc29uLnN0YXR1cyA9PT0gXCJyZWNvdmVyZWRcIikgcmVjb3ZlcmVkQ291bnQrKztcbi8vICAgICB9KTtcblxuLy8gICAgIGlmIChmcmFtZUNvdW50LmN1cnJlbnQgPiB0b3RhbERheXMgKiAzMCkge1xuLy8gICAgICAgcDUubm9Mb29wKCk7XG4vLyAgICAgfVxuLy8gICAgIC8vIFVwZGF0ZSB0aGUgY2hhcnQgZXZlcnkgZnJhbWVcbi8vICAgICBmcmFtZUNvdW50LmN1cnJlbnQrKztcbi8vICAgICB1cGRhdGVDaGFydERhdGEoXG4vLyAgICAgICBoZWFsdGh5Q291bnQsXG4vLyAgICAgICBpbmZlY3RlZENvdW50LFxuLy8gICAgICAgcmVjb3ZlcmVkQ291bnQsXG4vLyAgICAgICBmcmFtZUNvdW50LmN1cnJlbnRcbi8vICAgICApO1xuLy8gICB9O1xuXG4vLyAgIC8vIEhhbmRsZSBzcGVlZCBjaGFuZ2VzIHVzaW5nIHA1J3MgZnJhbWVSYXRlKClcbi8vICAgY29uc3QgaGFuZGxlU3BlZWRDaGFuZ2UgPSAoKSA9PiB7XG4vLyAgICAgaWYgKHNwZWVkID09PSAxKSB7XG4vLyAgICAgICBzZXRTcGVlZCgyKTsgLy8gU3BlZWQgdXAgdG8gMnhcbi8vICAgICAgIHA1SW5zdGFuY2UuY3VycmVudC5mcmFtZVJhdGUoNjApOyAvLyBEb3VibGUgdGhlIGZyYW1lIHJhdGUgZm9yIDJ4IHNwZWVkXG4vLyAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gMikge1xuLy8gICAgICAgc2V0U3BlZWQoNCk7IC8vIFNwZWVkIHVwIHRvIDR4XG4vLyAgICAgICBwNUluc3RhbmNlLmN1cnJlbnQuZnJhbWVSYXRlKDEyMCk7IC8vIFF1YWRydXBsZSB0aGUgZnJhbWUgcmF0ZSBmb3IgNHggc3BlZWRcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgc2V0U3BlZWQoMSk7IC8vIFJlc2V0IHRvIDF4IHNwZWVkXG4vLyAgICAgICBwNUluc3RhbmNlLmN1cnJlbnQuZnJhbWVSYXRlKDMwKTsgLy8gRGVmYXVsdCBmcmFtZSByYXRlXG4vLyAgICAgfVxuLy8gICB9O1xuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiBcImZsZXhcIiwgZ2FwOiBcIjIwcHhcIiB9fT5cbi8vICAgICAgIHsvKiBMZWZ0OiBTaW11bGF0aW9uICovfVxuLy8gICAgICAgPGRpdj5cbi8vICAgICAgICAgPGgyPkZsdSBTaW11bGF0aW9uPC9oMj5cbi8vICAgICAgICAgPHA+VmFjY2luZSBFZmZpY2FjeToge01hdGgucm91bmQodmFjY2luZUVmZmljYWN5ICogMTAwKX0lPC9wPlxuLy8gICAgICAgICA8cD5Qb3B1bGF0aW9uIFZhY2NpbmF0ZWQ6IHtNYXRoLnJvdW5kKHBvcHVsYXRpb25WYWNjaW5hdGVkICogMTAwKX0lPC9wPlxuLy8gICAgICAgICA8cD5JbmZlY3Rpb24gUHJvYmFiaWxpdHk6IHtNYXRoLnJvdW5kKGluZmVjdGlvblByb2JhYmlsaXR5ICogMTAwKX0lPC9wPlxuLy8gICAgICAgICA8cD5cbi8vICAgICAgICAgICB7XCIgXCJ9XG4vLyAgICAgICAgICAgVmFjY2luYXRlZCBSZWNvdmVyeSBSYXRlOiB7TWF0aC5yb3VuZCh2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlICogMTAwKX0lXG4vLyAgICAgICAgIDwvcD5cbi8vICAgICAgICAgPHA+XG4vLyAgICAgICAgICAgVW52YWNjaW5hdGVkIFJlY292ZXJ5IFJhdGU6e1wiIFwifVxuLy8gICAgICAgICAgIHtNYXRoLnJvdW5kKHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSAqIDEwMCl9JVxuLy8gICAgICAgICA8L3A+XG4vLyAgICAgICAgIDxwPlBlYWsgSW5mZWN0aW9uIERheToge3BlYWtJbmZlY3Rpb25EYXl9PC9wPlxuLy8gICAgICAgICA8cD5Ub3RhbCBEYXlzOiB7dG90YWxEYXlzfTwvcD5cbi8vICAgICAgICAgPHA+UG9wdWxhdGlvbiBTaXplOiB7cG9wdWxhdGlvblNpemV9PC9wPlxuXG4vLyAgICAgICAgIDxidXR0b24gb25DbGljaz17aGFuZGxlU3BlZWRDaGFuZ2V9PlxuLy8gICAgICAgICAgIHtzcGVlZCA9PT0gMVxuLy8gICAgICAgICAgICAgPyBcIlNwZWVkIFVwICgyeClcIlxuLy8gICAgICAgICAgICAgOiBzcGVlZCA9PT0gMlxuLy8gICAgICAgICAgICAgPyBcIlNwZWVkIFVwICg0eClcIlxuLy8gICAgICAgICAgICAgOiBcIlJlc2V0IFNwZWVkICgxeClcIn1cbi8vICAgICAgICAgPC9idXR0b24+XG5cbi8vICAgICAgICAgPFNrZXRjaCBzZXR1cD17c2V0dXB9IGRyYXc9e2RyYXd9IC8+XG4vLyAgICAgICA8L2Rpdj5cblxuLy8gICAgICAgey8qIFJpZ2h0OiBMaW5lIEdyYXBoICovfVxuLy8gICAgICAgPGRpdiBzdHlsZT17eyB3aWR0aDogXCI0MDBweFwiIH19PlxuLy8gICAgICAgICA8aDM+U3RhdHVzIE92ZXIgVGltZTwvaDM+XG4vLyAgICAgICAgIDxMaW5lIGRhdGE9e2NoYXJ0RGF0YX0gLz5cbi8vICAgICAgIDwvZGl2PlxuLy8gICAgIDwvZGl2PlxuLy8gICApO1xuLy8gfVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBcInVzZSBjbGllbnRcIjtcblxuLy8gaW1wb3J0IHsgdXNlU2VhcmNoUGFyYW1zIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuLy8gaW1wb3J0IGR5bmFtaWMgZnJvbSBcIm5leHQvZHluYW1pY1wiO1xuLy8gaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG4vLyBpbXBvcnQgeyBMaW5lIH0gZnJvbSBcInJlYWN0LWNoYXJ0anMtMlwiO1xuLy8gaW1wb3J0IHtcbi8vICAgQ2hhcnQgYXMgQ2hhcnRKUyxcbi8vICAgTGluZUVsZW1lbnQsXG4vLyAgIENhdGVnb3J5U2NhbGUsXG4vLyAgIExpbmVhclNjYWxlLFxuLy8gICBQb2ludEVsZW1lbnQsXG4vLyB9IGZyb20gXCJjaGFydC5qc1wiO1xuLy8gaW1wb3J0IE1vZGFsIGZyb20gJ3JlYWN0LW1vZGFsJztcblxuLy8gLy8gRHluYW1pY2FsbHkgbG9hZCByZWFjdC1wNSBzaW5jZSBwNS5qcyByZWxpZXMgb24gYnJvd3Nlci1zcGVjaWZpYyBmZWF0dXJlc1xuLy8gY29uc3QgU2tldGNoID0gZHluYW1pYygoKSA9PiBpbXBvcnQoXCJyZWFjdC1wNVwiKS50aGVuKChtb2QpID0+IG1vZC5kZWZhdWx0KSwge1xuLy8gICBzc3I6IGZhbHNlLFxuLy8gfSk7XG5cbi8vIC8vIFJlZ2lzdGVyIENoYXJ0LmpzIGNvbXBvbmVudHNcbi8vIENoYXJ0SlMucmVnaXN0ZXIoTGluZUVsZW1lbnQsIENhdGVnb3J5U2NhbGUsIExpbmVhclNjYWxlLCBQb2ludEVsZW1lbnQpO1xuXG4vLyAvLyBEZWZpbmUgY2hhcnQgZGF0YSB0eXBlXG4vLyB0eXBlIENoYXJ0RGF0YSA9IHtcbi8vICAgbGFiZWxzOiBudW1iZXJbXTtcbi8vICAgZGF0YXNldHM6IHtcbi8vICAgICBsYWJlbDogc3RyaW5nO1xuLy8gICAgIGRhdGE6IG51bWJlcltdO1xuLy8gICAgIGJvcmRlckNvbG9yOiBzdHJpbmc7XG4vLyAgICAgZmlsbDogYm9vbGVhbjtcbi8vICAgICBib3JkZXJEYXNoPzogbnVtYmVyW107XG4vLyAgIH1bXTtcbi8vIH07XG5cbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNpbXVsYXRpb24oKSB7XG5cbi8vICAgY29uc3QgW3Nob3dNb2RhbCwgc2V0U2hvd01vZGFsXSA9IHVzZVN0YXRlKGZhbHNlKTtcbi8vICAgY29uc3QgW2dyYXBocywgc2V0R3JhcGhzXSA9IHVzZVN0YXRlKFtdKTtcbi8vICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zKCk7XG5cbi8vICAgY29uc3QgYWRkTmV3R3JhcGggPSAobmV3UGFyYW1zKT0+IHtcbi8vICAgICBjb25zdCBuZXdHcmFwaERhdGEgPSBydW5TaW11bGF0aW9uKG5ld1BhcmFtcyk7XG4vLyAgICAgc2V0R3JhcGhzKFsuLi5ncmFwaHMsIG5ld0dyYXBoRGF0YV0pO1xuLy8gICAgIHNldFNob3dNb2RhbChmYWxzZSk7XG4vLyAgIH1cblxuLy8gICAvLyBFeHRyYWN0IHBhcmFtZXRlcnMgZnJvbSBVUkxcbi8vICAgY29uc3QgdmFjY2luZUVmZmljYWN5ID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwidmFjY2luZUVmZmljYWN5XCIpIHx8IFwiMC44XCJcbi8vICAgKTtcbi8vICAgY29uc3QgcG9wdWxhdGlvblZhY2NpbmF0ZWQgPSBwYXJzZUZsb2F0KFxuLy8gICAgIHNlYXJjaFBhcmFtcy5nZXQoXCJwb3B1bGF0aW9uVmFjY2luYXRlZFwiKSB8fCBcIjAuN1wiXG4vLyAgICk7XG4vLyAgIGNvbnN0IGluZmVjdGlvblByb2JhYmlsaXR5ID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwiaW5mZWN0aW9uUHJvYmFiaWxpdHlcIikgfHwgXCIwLjVcIlxuLy8gICApO1xuLy8gICBjb25zdCB2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwidmFjY2luYXRlZFJlY292ZXJ5UmF0ZVwiKSB8fCBcIjAuNVwiXG4vLyAgICk7XG4vLyAgIGNvbnN0IHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZVwiKSB8fCBcIjAuMVwiXG4vLyAgICk7XG4vLyAgIGNvbnN0IHBlYWtJbmZlY3Rpb25EYXkgPSBwYXJzZUludChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwicGVha0luZmVjdGlvbkRheVwiKSB8fCBcIjVcIlxuLy8gICApO1xuLy8gICBjb25zdCB0b3RhbERheXMgPSBwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KFwidG90YWxEYXlzXCIpIHx8IFwiMzBcIik7XG4vLyAgIGNvbnN0IHBvcHVsYXRpb25TaXplID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldChcInBvcHVsYXRpb25TaXplXCIpIHx8IFwiMTAwXCIpO1xuXG4vLyAgIC8vIFN0YXRlIGZvciBzaW11bGF0aW9uIGRhdGFcbi8vICAgY29uc3QgW2RheXMsIHNldERheXNdID0gdXNlU3RhdGU8bnVtYmVyW10+KFtdKTtcbi8vICAgY29uc3QgW3N1c2NlcHRpYmxlUG9wdWxhdGlvbiwgc2V0U3VzY2VwdGlibGVQb3B1bGF0aW9uXSA9IHVzZVN0YXRlPG51bWJlcltdPihcbi8vICAgICBbXVxuLy8gICApO1xuLy8gICBjb25zdCBbaW5mZWN0ZWRQb3B1bGF0aW9uLCBzZXRJbmZlY3RlZFBvcHVsYXRpb25dID0gdXNlU3RhdGU8bnVtYmVyW10+KFtdKTtcbi8vICAgY29uc3QgW3JlY292ZXJlZFZhY2NpbmF0ZWQsIHNldFJlY292ZXJlZFZhY2NpbmF0ZWRdID0gdXNlU3RhdGU8bnVtYmVyW10+KFtdKTtcbi8vICAgY29uc3QgW3JlY292ZXJlZFVudmFjY2luYXRlZCwgc2V0UmVjb3ZlcmVkVW52YWNjaW5hdGVkXSA9IHVzZVN0YXRlPG51bWJlcltdPihcbi8vICAgICBbXVxuLy8gICApO1xuLy8gICBjb25zdCBbdG90YWxSZWNvdmVyZWRQb3B1bGF0aW9uLCBzZXRUb3RhbFJlY292ZXJlZFBvcHVsYXRpb25dID0gdXNlU3RhdGU8XG4vLyAgICAgbnVtYmVyW11cbi8vICAgPihbXSk7XG4vLyAgIGNvbnN0IFtzcGVlZCwgc2V0U3BlZWRdID0gdXNlU3RhdGUoMSk7IC8vIDF4IHNwZWVkIGJ5IGRlZmF1bHRcblxuLy8gICBjb25zdCBwNUluc3RhbmNlID0gdXNlUmVmPGFueT4obnVsbCk7IC8vIFJlZmVyZW5jZSB0byBwNS5qcyBpbnN0YW5jZVxuXG4vLyAgIC8vIENoYXJ0IGRhdGFcbi8vICAgY29uc3QgW2NoYXJ0RGF0YSwgc2V0Q2hhcnREYXRhXSA9IHVzZVN0YXRlPENoYXJ0RGF0YT4oe1xuLy8gICAgIGxhYmVsczogW10sIC8vIEZyYW1lIGNvdW50IChvciB0aW1lIHN0ZXBzKVxuLy8gICAgIGRhdGFzZXRzOiBbXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGxhYmVsOiBcIlN1c2NlcHRpYmxlXCIsXG4vLyAgICAgICAgIGRhdGE6IFtdLFxuLy8gICAgICAgICBib3JkZXJDb2xvcjogXCJvcmFuZ2VcIixcbi8vICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICB9LFxuLy8gICAgICAge1xuLy8gICAgICAgICBsYWJlbDogXCJJbmZlY3RlZFwiLFxuLy8gICAgICAgICBkYXRhOiBbXSxcbi8vICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmVkXCIsXG4vLyAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgfSxcbi8vICAgICAgIHtcbi8vICAgICAgICAgbGFiZWw6IFwiVG90YWwgUmVjb3ZlcmVkXCIsXG4vLyAgICAgICAgIGRhdGE6IFtdLFxuLy8gICAgICAgICBib3JkZXJDb2xvcjogXCJncmVlblwiLFxuLy8gICAgICAgICBmaWxsOiBmYWxzZSxcbi8vICAgICAgIH0sXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGxhYmVsOiBcIlJlY292ZXJlZCBWYWNjaW5hdGVkXCIsXG4vLyAgICAgICAgIGRhdGE6IFtdLFxuLy8gICAgICAgICBib3JkZXJDb2xvcjogXCJibHVlXCIsXG4vLyAgICAgICAgIGJvcmRlckRhc2g6IFs1LCA1XSxcbi8vICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICB9LFxuLy8gICAgICAge1xuLy8gICAgICAgICBsYWJlbDogXCJSZWNvdmVyZWQgVW52YWNjaW5hdGVkXCIsXG4vLyAgICAgICAgIGRhdGE6IFtdLFxuLy8gICAgICAgICBib3JkZXJDb2xvcjogXCJwdXJwbGVcIixcbi8vICAgICAgICAgYm9yZGVyRGFzaDogWzUsIDVdLFxuLy8gICAgICAgICBmaWxsOiBmYWxzZSxcbi8vICAgICAgIH0sXG4vLyAgICAgXSxcbi8vICAgfSk7XG5cbi8vICAgLy8gSW5pdGlhbGl6ZSBhbmQgY2FsY3VsYXRlIGZsdSBtb2RlbCBkYXRhXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XG4vLyAgICAgY29uc3QgZGF5c0FycmF5ID0gQXJyYXkuZnJvbShcbi8vICAgICAgIHsgbGVuZ3RoOiAxMDAgfSxcbi8vICAgICAgIChfLCBpKSA9PiAoaSAvIDEwMCkgKiB0b3RhbERheXNcbi8vICAgICApO1xuLy8gICAgIHNldERheXMoZGF5c0FycmF5KTtcblxuLy8gICAgIGNvbnN0IHZhY2NpbmF0ZWRQb3B1bGF0aW9uID0gcG9wdWxhdGlvblNpemUgKiBwb3B1bGF0aW9uVmFjY2luYXRlZDtcbi8vICAgICBjb25zdCB1bnZhY2NpbmF0ZWRQb3B1bGF0aW9uID0gcG9wdWxhdGlvblNpemUgKiAoMSAtIHBvcHVsYXRpb25WYWNjaW5hdGVkKTtcblxuLy8gICAgIC8vIENhbGN1bGF0ZSByZWNvdmVyZWQgcG9wdWxhdGlvblxuLy8gICAgIGNvbnN0IHJlY292ZXJlZFZhY2NpbmF0ZWRBcnJheSA9IGRheXNBcnJheS5tYXAoXG4vLyAgICAgICAoZGF5KSA9PlxuLy8gICAgICAgICAoMSAvICgxICsgTWF0aC5leHAoLXZhY2NpbmF0ZWRSZWNvdmVyeVJhdGUgKiAoZGF5IC0gdG90YWxEYXlzIC8gMikpKSkgKlxuLy8gICAgICAgICB2YWNjaW5hdGVkUG9wdWxhdGlvblxuLy8gICAgICk7XG5cbi8vICAgICBjb25zdCByZWNvdmVyZWRVbnZhY2NpbmF0ZWRBcnJheSA9IGRheXNBcnJheS5tYXAoXG4vLyAgICAgICAoZGF5KSA9PlxuLy8gICAgICAgICAoMSAvXG4vLyAgICAgICAgICAgKDEgKyBNYXRoLmV4cCgtdW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlICogKGRheSAtIHRvdGFsRGF5cyAvIDIpKSkpICpcbi8vICAgICAgICAgdW52YWNjaW5hdGVkUG9wdWxhdGlvblxuLy8gICAgICk7XG5cbi8vICAgICBjb25zdCBpbmZlY3RlZEFycmF5ID0gZGF5c0FycmF5Lm1hcChcbi8vICAgICAgIChkYXkpID0+XG4vLyAgICAgICAgIE1hdGguZXhwKC1pbmZlY3Rpb25Qcm9iYWJpbGl0eSAqIChkYXkgLSBwZWFrSW5mZWN0aW9uRGF5KSAqKiAyKSAqXG4vLyAgICAgICAgIHBvcHVsYXRpb25TaXplXG4vLyAgICAgKTtcblxuLy8gICAgIGNvbnN0IHJlY292ZXJlZEFycmF5ID0gcmVjb3ZlcmVkVmFjY2luYXRlZEFycmF5Lm1hcChcbi8vICAgICAgIChydiwgaSkgPT4gcnYgKyByZWNvdmVyZWRVbnZhY2NpbmF0ZWRBcnJheVtpXVxuLy8gICAgICk7XG5cbi8vICAgICBjb25zdCBzdXNjZXB0aWJsZUFycmF5ID0gZGF5c0FycmF5Lm1hcCgoXywgaSkgPT4ge1xuLy8gICAgICAgY29uc3Qgc3VzY2VwdGlibGVWYWx1ZSA9XG4vLyAgICAgICAgIHBvcHVsYXRpb25TaXplIC0gKGluZmVjdGVkQXJyYXlbaV0gKyByZWNvdmVyZWRBcnJheVtpXSk7XG4vLyAgICAgICByZXR1cm4gTWF0aC5tYXgoc3VzY2VwdGlibGVWYWx1ZSwgMCk7IC8vIEVuc3VyZSBubyBuZWdhdGl2ZSB2YWx1ZXNcbi8vICAgICB9KTtcblxuLy8gICAgIC8vIFNldCBjYWxjdWxhdGVkIHN0YXRlIHZhcmlhYmxlc1xuLy8gICAgIHNldFN1c2NlcHRpYmxlUG9wdWxhdGlvbihzdXNjZXB0aWJsZUFycmF5KTtcbi8vICAgICBzZXRJbmZlY3RlZFBvcHVsYXRpb24oaW5mZWN0ZWRBcnJheSk7XG4vLyAgICAgc2V0UmVjb3ZlcmVkVmFjY2luYXRlZChyZWNvdmVyZWRWYWNjaW5hdGVkQXJyYXkpO1xuLy8gICAgIHNldFJlY292ZXJlZFVudmFjY2luYXRlZChyZWNvdmVyZWRVbnZhY2NpbmF0ZWRBcnJheSk7XG4vLyAgICAgc2V0VG90YWxSZWNvdmVyZWRQb3B1bGF0aW9uKHJlY292ZXJlZEFycmF5KTtcbi8vICAgfSwgW1xuLy8gICAgIGluZmVjdGlvblByb2JhYmlsaXR5LFxuLy8gICAgIHZhY2NpbmF0ZWRSZWNvdmVyeVJhdGUsXG4vLyAgICAgdW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlLFxuLy8gICAgIHBvcHVsYXRpb25WYWNjaW5hdGVkLFxuLy8gICAgIHBlYWtJbmZlY3Rpb25EYXksXG4vLyAgICAgdG90YWxEYXlzLFxuLy8gICAgIHBvcHVsYXRpb25TaXplLFxuLy8gICBdKTtcblxuLy8gICAvLyBVcGRhdGUgY2hhcnQgZGF0YSB3aGVuIHN0YXRlIGNoYW5nZXNcbi8vICAgdXNlRWZmZWN0KCgpID0+IHtcbi8vICAgICBzZXRDaGFydERhdGEoe1xuLy8gICAgICAgbGFiZWxzOiBkYXlzLFxuLy8gICAgICAgZGF0YXNldHM6IFtcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIGxhYmVsOiBcIlN1c2NlcHRpYmxlXCIsXG4vLyAgICAgICAgICAgZGF0YTogc3VzY2VwdGlibGVQb3B1bGF0aW9uLFxuLy8gICAgICAgICAgIGJvcmRlckNvbG9yOiBcIm9yYW5nZVwiLFxuLy8gICAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgbGFiZWw6IFwiSW5mZWN0ZWRcIixcbi8vICAgICAgICAgICBkYXRhOiBpbmZlY3RlZFBvcHVsYXRpb24sXG4vLyAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmVkXCIsXG4vLyAgICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICBsYWJlbDogXCJUb3RhbCBSZWNvdmVyZWRcIixcbi8vICAgICAgICAgICBkYXRhOiB0b3RhbFJlY292ZXJlZFBvcHVsYXRpb24sXG4vLyAgICAgICAgICAgYm9yZGVyQ29sb3I6IFwiZ3JlZW5cIixcbi8vICAgICAgICAgICBmaWxsOiBmYWxzZSxcbi8vICAgICAgICAgfSxcbi8vICAgICAgICAge1xuLy8gICAgICAgICAgIGxhYmVsOiBcIlJlY292ZXJlZCBWYWNjaW5hdGVkXCIsXG4vLyAgICAgICAgICAgZGF0YTogcmVjb3ZlcmVkVmFjY2luYXRlZCxcbi8vICAgICAgICAgICBib3JkZXJDb2xvcjogXCJibHVlXCIsXG4vLyAgICAgICAgICAgYm9yZGVyRGFzaDogWzUsIDVdLFxuLy8gICAgICAgICAgIGZpbGw6IGZhbHNlLFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgbGFiZWw6IFwiUmVjb3ZlcmVkIFVudmFjY2luYXRlZFwiLFxuLy8gICAgICAgICAgIGRhdGE6IHJlY292ZXJlZFVudmFjY2luYXRlZCxcbi8vICAgICAgICAgICBib3JkZXJDb2xvcjogXCJwdXJwbGVcIixcbi8vICAgICAgICAgICBib3JkZXJEYXNoOiBbNSwgNV0sXG4vLyAgICAgICAgICAgZmlsbDogZmFsc2UsXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICBdLFxuLy8gICAgIH0pO1xuLy8gICB9LCBbXG4vLyAgICAgZGF5cyxcbi8vICAgICBzdXNjZXB0aWJsZVBvcHVsYXRpb24sXG4vLyAgICAgaW5mZWN0ZWRQb3B1bGF0aW9uLFxuLy8gICAgIHRvdGFsUmVjb3ZlcmVkUG9wdWxhdGlvbixcbi8vICAgICByZWNvdmVyZWRWYWNjaW5hdGVkLFxuLy8gICAgIHJlY292ZXJlZFVudmFjY2luYXRlZCxcbi8vICAgXSk7XG5cbi8vICAgLy8gcDUuanMgc2V0dXAgYW5kIGRyYXcgZnVuY3Rpb25zXG4vLyAgIGNvbnN0IHNldHVwID0gKHA1OiBhbnksIGNhbnZhc1BhcmVudFJlZjogRWxlbWVudCkgPT4ge1xuLy8gICAgIHA1LmNyZWF0ZUNhbnZhcyg4MDAsIDYwMCkucGFyZW50KGNhbnZhc1BhcmVudFJlZik7XG4vLyAgICAgcDVJbnN0YW5jZS5jdXJyZW50ID0gcDU7XG4vLyAgICAgcDUuZnJhbWVSYXRlKDMwKTtcbi8vICAgfTtcblxuLy8gICBjb25zdCBkcmF3ID0gKHA1OiBhbnkpID0+IHtcbi8vICAgICBwNS5iYWNrZ3JvdW5kKDI1NSk7XG4vLyAgIH07XG5cbi8vICAgLy8gSGFuZGxlIHNwZWVkIGNoYW5nZXMgdXNpbmcgcDUncyBmcmFtZVJhdGUoKVxuLy8gICBjb25zdCBoYW5kbGVTcGVlZENoYW5nZSA9ICgpID0+IHtcbi8vICAgICBpZiAoc3BlZWQgPT09IDEpIHtcbi8vICAgICAgIHNldFNwZWVkKDIpO1xuLy8gICAgICAgcDVJbnN0YW5jZS5jdXJyZW50LmZyYW1lUmF0ZSg2MCk7XG4vLyAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gMikge1xuLy8gICAgICAgc2V0U3BlZWQoNCk7XG4vLyAgICAgICBwNUluc3RhbmNlLmN1cnJlbnQuZnJhbWVSYXRlKDEyMCk7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgIHNldFNwZWVkKDEpO1xuLy8gICAgICAgcDVJbnN0YW5jZS5jdXJyZW50LmZyYW1lUmF0ZSgzMCk7XG4vLyAgICAgfVxuLy8gICB9O1xuXG4vLyAgIHJldHVybiAoXG4vLyAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiBcImZsZXhcIiwgZ2FwOiBcIjIwcHhcIiB9fT5cbi8vICAgICAgIHsvKiBMZWZ0OiBTaW11bGF0aW9uICovfVxuLy8gICAgICAgPGRpdj5cbi8vICAgICAgICAgPGgyPkZsdSBTaW11bGF0aW9uPC9oMj5cbi8vICAgICAgICAgPHA+VmFjY2luZSBFZmZpY2FjeToge01hdGgucm91bmQodmFjY2luZUVmZmljYWN5ICogMTAwKX0lPC9wPlxuLy8gICAgICAgICA8cD5Qb3B1bGF0aW9uIFZhY2NpbmF0ZWQ6IHtNYXRoLnJvdW5kKHBvcHVsYXRpb25WYWNjaW5hdGVkICogMTAwKX0lPC9wPlxuLy8gICAgICAgICA8cD5JbmZlY3Rpb24gUHJvYmFiaWxpdHk6IHtNYXRoLnJvdW5kKGluZmVjdGlvblByb2JhYmlsaXR5ICogMTAwKX0lPC9wPlxuLy8gICAgICAgICA8cD5cbi8vICAgICAgICAgICBWYWNjaW5hdGVkIFJlY292ZXJ5IFJhdGU6IHtNYXRoLnJvdW5kKHZhY2NpbmF0ZWRSZWNvdmVyeVJhdGUgKiAxMDApfSVcbi8vICAgICAgICAgPC9wPlxuLy8gICAgICAgICA8cD5cbi8vICAgICAgICAgICBVbnZhY2NpbmF0ZWQgUmVjb3ZlcnkgUmF0ZTp7XCIgXCJ9XG4vLyAgICAgICAgICAge01hdGgucm91bmQodW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlICogMTAwKX0lXG4vLyAgICAgICAgIDwvcD5cbi8vICAgICAgICAgPHA+UGVhayBJbmZlY3Rpb24gRGF5OiB7cGVha0luZmVjdGlvbkRheX08L3A+XG4vLyAgICAgICAgIDxwPlRvdGFsIERheXM6IHt0b3RhbERheXN9PC9wPlxuLy8gICAgICAgICA8cD5Qb3B1bGF0aW9uIFNpemU6IHtwb3B1bGF0aW9uU2l6ZX08L3A+XG5cbi8vICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVTcGVlZENoYW5nZX0+XG4vLyAgICAgICAgICAge3NwZWVkID09PSAxXG4vLyAgICAgICAgICAgICA/IFwiU3BlZWQgVXAgKDJ4KVwiXG4vLyAgICAgICAgICAgICA6IHNwZWVkID09PSAyXG4vLyAgICAgICAgICAgICA/IFwiU3BlZWQgVXAgKDR4KVwiXG4vLyAgICAgICAgICAgICA6IFwiUmVzZXQgU3BlZWQgKDF4KVwifVxuLy8gICAgICAgICA8L2J1dHRvbj5cblxuLy8gICAgICAgICA8U2tldGNoIHNldHVwPXtzZXR1cH0gZHJhdz17ZHJhd30gLz5cbi8vICAgICAgIDwvZGl2PlxuXG4vLyAgICAgICB7LyogUmlnaHQ6IExpbmUgR3JhcGggKi99XG4vLyAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiBcIjQwMHB4XCIgfX0+XG4vLyAgICAgICAgIDxoMz5TdGF0dXMgT3ZlciBUaW1lPC9oMz5cbi8vICAgICAgICAgPExpbmUgZGF0YT17Y2hhcnREYXRhfSAvPlxuLy8gICAgICAgPC9kaXY+XG5cbi8vICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRTaG93TW9kYWwodHJ1ZSl9PkFkZCBOZXc8L2J1dHRvbj5cblxuLy8gICAgICAgey8qIE1vZGFsIGZvciBhZGRpbmcgbmV3IGdyYXBoICovfVxuLy8gICAgICAgPE1vZGFsIGlzT3Blbj17c2hvd01vZGFsfSBvblJlcXVlc3RDbG9zZT17KCkgPT4gc2V0U2hvd01vZGFsKGZhbHNlKX0+XG4vLyAgICAgICAgIDxoMj5FbnRlciBOZXcgUGFyYW1ldGVyczwvaDI+XG4vLyAgICAgICAgIDxQYXJhbWV0ZXJGb3JtIG9uU3VibWl0PXthZGROZXdHcmFwaH0gY2xvc2VNb2RhbD17KCkgPT4gc2V0U2hvd01vZGFsKGZhbHNlKX0gLz5cbi8vICAgICAgIDwvTW9kYWw+XG5cbi8vICAgICAgIHsvKiBEaXNwbGF5IGFsbCBncmFwaHMgKi99XG4vLyAgICAgICB7Z3JhcGhzLm1hcCgoZ3JhcGgsIGluZGV4KSA9PiAoXG4vLyAgICAgICAgIDxkaXYga2V5PXtpbmRleH0+XG4vLyAgICAgICAgICAgPGgzPkdyYXBoIHtpbmRleCArIDF9PC9oMz5cbi8vICAgICAgICAgICA8TGluZSBkYXRhPXtncmFwaH0gLz5cbi8vICAgICAgICAgPC9kaXY+XG4vLyAgICAgICApKX1cbi8vICAgICA8L2Rpdj5cbi8vICAgKTtcblxuLy8gfVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gXCJ1c2UgY2xpZW50XCI7XG5cbi8vIGltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbi8vIGltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuLy8gaW1wb3J0IFNpbXVsYXRpb25Db250cm9scyBmcm9tIFwiLi9jb21wb25lbnRzL1NpbXVsYXRpb25Db250cm9sc1wiO1xuLy8gaW1wb3J0IFBvcHVsYXRpb25DYW52YXMgZnJvbSBcIi4vY29tcG9uZW50cy9Qb3B1bGF0aW9uQ2FudmFzXCI7XG4vLyBpbXBvcnQgU3RhdHVzQ2hhcnQgZnJvbSBcIi4vY29tcG9uZW50cy9TdGF0dXNDaGFydFwiO1xuLy8gaW1wb3J0IFBlcnNvbiBmcm9tIFwiLi9jb21wb25lbnRzL1BlcnNvblwiO1xuXG4vLyB0eXBlIENoYXJ0RGF0YSA9IHtcbi8vICAgbGFiZWxzOiBudW1iZXJbXTtcbi8vICAgZGF0YXNldHM6IHtcbi8vICAgICBsYWJlbDogc3RyaW5nO1xuLy8gICAgIGRhdGE6IG51bWJlcltdO1xuLy8gICAgIGJvcmRlckNvbG9yOiBzdHJpbmc7XG4vLyAgICAgZmlsbDogYm9vbGVhbjtcbi8vICAgfVtdO1xuLy8gfTtcblxuLy8gZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2ltdWxhdGlvbigpIHtcbi8vICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zKCk7XG5cbi8vICAgY29uc3QgdmFjY2luZUVmZmljYWN5ID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwidmFjY2luZUVmZmljYWN5XCIpIHx8IFwiMC44XCJcbi8vICAgKTtcbi8vICAgY29uc3QgcG9wdWxhdGlvblZhY2NpbmF0ZWQgPSBwYXJzZUZsb2F0KFxuLy8gICAgIHNlYXJjaFBhcmFtcy5nZXQoXCJwb3B1bGF0aW9uVmFjY2luYXRlZFwiKSB8fCBcIjAuN1wiXG4vLyAgICk7XG4vLyAgIGNvbnN0IGluZmVjdGlvblByb2JhYmlsaXR5ID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwiaW5mZWN0aW9uUHJvYmFiaWxpdHlcIikgfHwgXCIwLjVcIlxuLy8gICApO1xuLy8gICBjb25zdCB2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlID0gcGFyc2VGbG9hdChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwidmFjY2luYXRlZFJlY292ZXJ5UmF0ZVwiKSB8fCBcIjAuNVwiXG4vLyAgICk7XG4vLyAgIGNvbnN0IHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSA9IHBhcnNlRmxvYXQoXG4vLyAgICAgc2VhcmNoUGFyYW1zLmdldChcInVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZVwiKSB8fCBcIjAuMVwiXG4vLyAgICk7XG4vLyAgIGNvbnN0IHBlYWtJbmZlY3Rpb25EYXkgPSBwYXJzZUludChcbi8vICAgICBzZWFyY2hQYXJhbXMuZ2V0KFwicGVha0luZmVjdGlvbkRheVwiKSB8fCBcIjVcIlxuLy8gICApO1xuLy8gICBjb25zdCB0b3RhbERheXMgPSBwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KFwidG90YWxEYXlzXCIpIHx8IFwiMzBcIik7XG4vLyAgIGNvbnN0IHBvcHVsYXRpb25TaXplID0gcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldChcInBvcHVsYXRpb25TaXplXCIpIHx8IFwiMjUwXCIpO1xuXG4vLyAgIGNvbnN0IFtwZW9wbGUsIHNldFBlb3BsZV0gPSB1c2VTdGF0ZTxQZXJzb25bXT4oW10pO1xuLy8gICBjb25zdCBbc3BlZWQsIHNldFNwZWVkXSA9IHVzZVN0YXRlKDEpO1xuLy8gICBjb25zdCBbY2hhcnREYXRhLCBzZXRDaGFydERhdGFdID0gdXNlU3RhdGU8Q2hhcnREYXRhPih7XG4vLyAgICAgbGFiZWxzOiBbXSxcbi8vICAgICBkYXRhc2V0czogW1xuLy8gICAgICAgeyBsYWJlbDogXCJIZWFsdGh5XCIsIGRhdGE6IFtdLCBib3JkZXJDb2xvcjogXCJibHVlXCIsIGZpbGw6IGZhbHNlIH0sXG4vLyAgICAgICB7IGxhYmVsOiBcIkluZmVjdGVkXCIsIGRhdGE6IFtdLCBib3JkZXJDb2xvcjogXCJyZWRcIiwgZmlsbDogZmFsc2UgfSxcbi8vICAgICAgIHsgbGFiZWw6IFwiUmVjb3ZlcmVkXCIsIGRhdGE6IFtdLCBib3JkZXJDb2xvcjogXCJncmVlblwiLCBmaWxsOiBmYWxzZSB9LFxuLy8gICAgIF0sXG4vLyAgIH0pO1xuXG4vLyAgIGNvbnN0IHVwZGF0ZUNoYXJ0RGF0YSA9IChcbi8vICAgICBoZWFsdGh5OiBudW1iZXIsXG4vLyAgICAgaW5mZWN0ZWQ6IG51bWJlcixcbi8vICAgICByZWNvdmVyZWQ6IG51bWJlcixcbi8vICAgICBmcmFtZTogbnVtYmVyXG4vLyAgICkgPT4ge1xuLy8gICAgIHNldENoYXJ0RGF0YSgocHJldkRhdGEpID0+ICh7XG4vLyAgICAgICBsYWJlbHM6IFsuLi5wcmV2RGF0YS5sYWJlbHMsIGZyYW1lXSxcbi8vICAgICAgIGRhdGFzZXRzOiBbXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICAuLi5wcmV2RGF0YS5kYXRhc2V0c1swXSxcbi8vICAgICAgICAgICBkYXRhOiBbLi4ucHJldkRhdGEuZGF0YXNldHNbMF0uZGF0YSwgaGVhbHRoeV0sXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICAgIHtcbi8vICAgICAgICAgICAuLi5wcmV2RGF0YS5kYXRhc2V0c1sxXSxcbi8vICAgICAgICAgICBkYXRhOiBbLi4ucHJldkRhdGEuZGF0YXNldHNbMV0uZGF0YSwgaW5mZWN0ZWRdLFxuLy8gICAgICAgICB9LFxuLy8gICAgICAgICB7XG4vLyAgICAgICAgICAgLi4ucHJldkRhdGEuZGF0YXNldHNbMl0sXG4vLyAgICAgICAgICAgZGF0YTogWy4uLnByZXZEYXRhLmRhdGFzZXRzWzJdLmRhdGEsIHJlY292ZXJlZF0sXG4vLyAgICAgICAgIH0sXG4vLyAgICAgICBdLFxuLy8gICAgIH0pKTtcbi8vICAgfTtcblxuLy8gICBjb25zdCBoYW5kbGVTcGVlZENoYW5nZSA9ICgpID0+XG4vLyAgICAgc2V0U3BlZWQoKHByZXYpID0+IChwcmV2ID09PSAxID8gMiA6IHByZXYgPT09IDIgPyA0IDogMSkpO1xuXG4vLyAgIHVzZUVmZmVjdCgoKSA9PiB7XG4vLyAgICAgY29uc3QgbmV3UGVvcGxlOiBQZXJzb25bXSA9IFtdO1xuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9wdWxhdGlvblNpemU7IGkrKykge1xuLy8gICAgICAgY29uc3QgeCA9IE1hdGgucmFuZG9tKCkgKiA4MDA7XG4vLyAgICAgICBjb25zdCB5ID0gTWF0aC5yYW5kb20oKSAqIDYwMDtcbi8vICAgICAgIGNvbnN0IHZhY2NpbmF0ZWQgPSBNYXRoLnJhbmRvbSgpIDwgcG9wdWxhdGlvblZhY2NpbmF0ZWQ7XG4vLyAgICAgICBuZXdQZW9wbGUucHVzaChuZXcgUGVyc29uKHgsIHksIHZhY2NpbmF0ZWQpKTtcbi8vICAgICB9XG4vLyAgICAgc2V0UGVvcGxlKG5ld1Blb3BsZSk7XG4vLyAgIH0sIFtwb3B1bGF0aW9uU2l6ZSwgcG9wdWxhdGlvblZhY2NpbmF0ZWRdKTtcblxuLy8gICByZXR1cm4gKFxuLy8gICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogXCJmbGV4XCIsIGdhcDogXCIyMHB4XCIgfX0+XG4vLyAgICAgICA8U2ltdWxhdGlvbkNvbnRyb2xzXG4vLyAgICAgICAgIHZhY2NpbmVFZmZpY2FjeT17dmFjY2luZUVmZmljYWN5fVxuLy8gICAgICAgICBwb3B1bGF0aW9uVmFjY2luYXRlZD17cG9wdWxhdGlvblZhY2NpbmF0ZWR9XG4vLyAgICAgICAgIGluZmVjdGlvblByb2JhYmlsaXR5PXtpbmZlY3Rpb25Qcm9iYWJpbGl0eX1cbi8vICAgICAgICAgdmFjY2luYXRlZFJlY292ZXJ5UmF0ZT17dmFjY2luYXRlZFJlY292ZXJ5UmF0ZX1cbi8vICAgICAgICAgdW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlPXt1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGV9XG4vLyAgICAgICAgIHBlYWtJbmZlY3Rpb25EYXk9e3BlYWtJbmZlY3Rpb25EYXl9XG4vLyAgICAgICAgIHRvdGFsRGF5cz17dG90YWxEYXlzfVxuLy8gICAgICAgICBwb3B1bGF0aW9uU2l6ZT17cG9wdWxhdGlvblNpemV9XG4vLyAgICAgICAgIHNwZWVkPXtzcGVlZH1cbi8vICAgICAgICAgaGFuZGxlU3BlZWRDaGFuZ2U9e2hhbmRsZVNwZWVkQ2hhbmdlfVxuLy8gICAgICAgLz5cbi8vICAgICAgIDxQb3B1bGF0aW9uQ2FudmFzXG4vLyAgICAgICAgIHBlb3BsZT17cGVvcGxlfVxuLy8gICAgICAgICB2YWNjaW5lRWZmaWNhY3k9e3ZhY2NpbmVFZmZpY2FjeX1cbi8vICAgICAgICAgaW5mZWN0aW9uUHJvYmFiaWxpdHk9e2luZmVjdGlvblByb2JhYmlsaXR5fVxuLy8gICAgICAgICB2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlPXt2YWNjaW5hdGVkUmVjb3ZlcnlSYXRlfVxuLy8gICAgICAgICB1bnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGU9e3VudmFjY2luYXRlZFJlY292ZXJ5UmF0ZX1cbi8vICAgICAgICAgdG90YWxEYXlzPXt0b3RhbERheXN9XG4vLyAgICAgICAgIHVwZGF0ZUNoYXJ0RGF0YT17dXBkYXRlQ2hhcnREYXRhfVxuLy8gICAgICAgLz5cbi8vICAgICAgIDxTdGF0dXNDaGFydCBjaGFydERhdGE9e2NoYXJ0RGF0YX0gLz5cbi8vICAgICA8L2Rpdj5cbi8vICAgKTtcbi8vIH1cblxuLy8tLS0tLS0tLS1cblxuXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcywgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFNpbXVsYXRpb25Db250cm9scyBmcm9tIFwiLi9jb21wb25lbnRzL1NpbXVsYXRpb25Db250cm9sc1wiO1xuaW1wb3J0IFBvcHVsYXRpb25DYW52YXMgZnJvbSBcIi4vY29tcG9uZW50cy9Qb3B1bGF0aW9uQ2FudmFzXCI7XG5pbXBvcnQgU3RhdHVzQ2hhcnQgZnJvbSBcIi4vY29tcG9uZW50cy9TdGF0dXNDaGFydFwiO1xuaW1wb3J0IFNpbXVsYXRpb25Db250cm9sc1BvcCBmcm9tIFwiLi9jb21wb25lbnRzL1NpbXVsYXRpb25Db250cm9sc1BvcG92ZXJcIjtcbmltcG9ydCBQZXJzb24gZnJvbSBcIi4vY29tcG9uZW50cy9QZXJzb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2ltdWxhdGlvbigpIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zKCk7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuXG4gIC8vIFN0YXRlIHRvIG1hbmFnZSBsaXN0IG9mIHNpbXVsYXRpb25zXG4gIGNvbnN0IFtzaW11bGF0aW9ucywgc2V0U2ltdWxhdGlvbnNdID0gdXNlU3RhdGU8YW55W10+KFtdKTtcblxuICAvLyBQYXJhbWV0ZXIgcmV0cmlldmFsIGZ1bmN0aW9uXG4gIGNvbnN0IGdldFNpbXVsYXRpb25QYXJhbXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhY2NpbmVFZmZpY2FjeTogcGFyc2VGbG9hdChzZWFyY2hQYXJhbXMuZ2V0KFwidmFjY2luZUVmZmljYWN5XCIpIHx8IFwiMC44XCIpLFxuICAgICAgcG9wdWxhdGlvblZhY2NpbmF0ZWQ6IHBhcnNlRmxvYXQoc2VhcmNoUGFyYW1zLmdldChcInBvcHVsYXRpb25WYWNjaW5hdGVkXCIpIHx8IFwiMC43XCIpLFxuICAgICAgaW5mZWN0aW9uUHJvYmFiaWxpdHk6IHBhcnNlRmxvYXQoc2VhcmNoUGFyYW1zLmdldChcImluZmVjdGlvblByb2JhYmlsaXR5XCIpIHx8IFwiMC41XCIpLFxuICAgICAgdmFjY2luYXRlZFJlY292ZXJ5UmF0ZTogcGFyc2VGbG9hdChzZWFyY2hQYXJhbXMuZ2V0KFwidmFjY2luYXRlZFJlY292ZXJ5UmF0ZVwiKSB8fCBcIjAuNVwiKSxcbiAgICAgIHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZTogcGFyc2VGbG9hdChzZWFyY2hQYXJhbXMuZ2V0KFwidW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlXCIpIHx8IFwiMC4xXCIpLFxuICAgICAgcGVha0luZmVjdGlvbkRheTogcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldChcInBlYWtJbmZlY3Rpb25EYXlcIikgfHwgXCI1XCIpLFxuICAgICAgdG90YWxEYXlzOiBwYXJzZUludChzZWFyY2hQYXJhbXMuZ2V0KFwidG90YWxEYXlzXCIpIHx8IFwiMzBcIiksXG4gICAgICBwb3B1bGF0aW9uU2l6ZTogcGFyc2VJbnQoc2VhcmNoUGFyYW1zLmdldChcInBvcHVsYXRpb25TaXplXCIpIHx8IFwiMjUwXCIpLFxuICAgIH07XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gdG8gYWRkIGEgbmV3IHNpbXVsYXRpb25cbiAgY29uc3QgYWRkU2ltdWxhdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSBnZXRTaW11bGF0aW9uUGFyYW1zKCk7XG4gICAgY29uc3QgbmV3UGVvcGxlOiBQZXJzb25bXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLnBvcHVsYXRpb25TaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBNYXRoLnJhbmRvbSgpICogODAwO1xuICAgICAgY29uc3QgeSA9IE1hdGgucmFuZG9tKCkgKiA2MDA7XG4gICAgICBjb25zdCB2YWNjaW5hdGVkID0gTWF0aC5yYW5kb20oKSA8IHBhcmFtcy5wb3B1bGF0aW9uVmFjY2luYXRlZDtcbiAgICAgIG5ld1Blb3BsZS5wdXNoKG5ldyBQZXJzb24oeCwgeSwgdmFjY2luYXRlZCkpO1xuICAgIH1cblxuICAgIC8vIENoYXJ0IERhdGEgSW5pdGlhbCBTdGF0ZVxuICAgIGNvbnN0IGluaXRpYWxDaGFydERhdGEgPSB7XG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgZGF0YXNldHM6IFtcbiAgICAgICAgeyBsYWJlbDogXCJIZWFsdGh5XCIsIGRhdGE6IFtdLCBib3JkZXJDb2xvcjogXCJibHVlXCIsIGZpbGw6IGZhbHNlIH0sXG4gICAgICAgIHsgbGFiZWw6IFwiSW5mZWN0ZWRcIiwgZGF0YTogW10sIGJvcmRlckNvbG9yOiBcInJlZFwiLCBmaWxsOiBmYWxzZSB9LFxuICAgICAgICB7IGxhYmVsOiBcIlJlY292ZXJlZFwiLCBkYXRhOiBbXSwgYm9yZGVyQ29sb3I6IFwiZ3JlZW5cIiwgZmlsbDogZmFsc2UgfSxcbiAgICAgIF0sXG4gICAgfTtcblxuICAgIHNldFNpbXVsYXRpb25zKChwcmV2U2ltdWxhdGlvbnMpID0+IFtcbiAgICAgIC4uLnByZXZTaW11bGF0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwZW9wbGU6IG5ld1Blb3BsZSxcbiAgICAgICAgY2hhcnREYXRhOiBpbml0aWFsQ2hhcnREYXRhLFxuICAgICAgICBjdXJyZW50RGF5OiAwLFxuICAgICAgfSxcbiAgICBdKTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgY2hhcnQgZGF0YVxuICBjb25zdCB1cGRhdGVDaGFydERhdGEgPSAoXG4gICAgc2ltdWxhdGlvbkluZGV4OiBudW1iZXIsXG4gICAgaGVhbHRoeTogbnVtYmVyLFxuICAgIGluZmVjdGVkOiBudW1iZXIsXG4gICAgcmVjb3ZlcmVkOiBudW1iZXIsXG4gICAgZnJhbWU6IG51bWJlclxuICApID0+IHtcbiAgICBzZXRTaW11bGF0aW9ucygocHJldlNpbXVsYXRpb25zKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkU2ltdWxhdGlvbnMgPSBbLi4ucHJldlNpbXVsYXRpb25zXTtcbiAgICAgIHVwZGF0ZWRTaW11bGF0aW9uc1tzaW11bGF0aW9uSW5kZXhdLmNoYXJ0RGF0YS5sYWJlbHMucHVzaChmcmFtZSk7XG4gICAgICB1cGRhdGVkU2ltdWxhdGlvbnNbc2ltdWxhdGlvbkluZGV4XS5jaGFydERhdGEuZGF0YXNldHNbMF0uZGF0YS5wdXNoKGhlYWx0aHkpO1xuICAgICAgdXBkYXRlZFNpbXVsYXRpb25zW3NpbXVsYXRpb25JbmRleF0uY2hhcnREYXRhLmRhdGFzZXRzWzFdLmRhdGEucHVzaChpbmZlY3RlZCk7XG4gICAgICB1cGRhdGVkU2ltdWxhdGlvbnNbc2ltdWxhdGlvbkluZGV4XS5jaGFydERhdGEuZGF0YXNldHNbMl0uZGF0YS5wdXNoKHJlY292ZXJlZCk7XG4gICAgICByZXR1cm4gdXBkYXRlZFNpbXVsYXRpb25zO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEVmZmVjdCB0byBpbml0aWFsaXplIHRoZSBzaW11bGF0aW9uIGFuZCB1cGRhdGUgaXQgb3ZlciB0aW1lXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGFuIGludGVydmFsIHRvIHNpbXVsYXRlIHRoZSBzcHJlYWQgYW5kIHVwZGF0ZSB0aGUgY2hhcnRzXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXRTaW11bGF0aW9ucygocHJldlNpbXVsYXRpb25zKSA9PlxuICAgICAgICBwcmV2U2ltdWxhdGlvbnMubWFwKChzaW11bGF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgY3VycmVudERheSwgcGFyYW1zLCBwZW9wbGUgfSA9IHNpbXVsYXRpb247XG5cbiAgICAgICAgICAvLyBTdG9wIHVwZGF0aW5nIGlmIHRoZSBzaW11bGF0aW9uIGhhcyByZWFjaGVkIGl0cyB0b3RhbCBkYXlzXG4gICAgICAgICAgaWYgKGN1cnJlbnREYXkgPj0gcGFyYW1zLnRvdGFsRGF5cykge1xuICAgICAgICAgICAgcmV0dXJuIHNpbXVsYXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2ltdWxhdGUgdGhlIGRpc2Vhc2Ugc3ByZWFkIGFuZCByZWNvdmVyeVxuICAgICAgICAgIGxldCBoZWFsdGh5ID0gMCxcbiAgICAgICAgICAgIGluZmVjdGVkID0gMCxcbiAgICAgICAgICAgIHJlY292ZXJlZCA9IDA7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgcGVvcGxlIHN0YXR1c1xuICAgICAgICAgIHBlb3BsZS5mb3JFYWNoKChwZXJzb246IHsgdXBkYXRlU3RhdHVzOiAoYXJnMDogYW55LCBhcmcxOiBhbnksIGFyZzI6IGFueSwgYXJnMzogYW55KSA9PiB2b2lkOyBpc0hlYWx0aHk6ICgpID0+IGFueTsgaXNJbmZlY3RlZDogKCkgPT4gYW55OyBpc1JlY292ZXJlZDogKCkgPT4gYW55OyB9KSA9PiB7XG4gICAgICAgICAgICBwZXJzb24udXBkYXRlU3RhdHVzKFxuICAgICAgICAgICAgICBwYXJhbXMuaW5mZWN0aW9uUHJvYmFiaWxpdHksXG4gICAgICAgICAgICAgIHBhcmFtcy52YWNjaW5lRWZmaWNhY3ksXG4gICAgICAgICAgICAgIHBhcmFtcy52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlLFxuICAgICAgICAgICAgICBwYXJhbXMudW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAocGVyc29uLmlzSGVhbHRoeSgpKSBoZWFsdGh5Kys7XG4gICAgICAgICAgICBlbHNlIGlmIChwZXJzb24uaXNJbmZlY3RlZCgpKSBpbmZlY3RlZCsrO1xuICAgICAgICAgICAgZWxzZSBpZiAocGVyc29uLmlzUmVjb3ZlcmVkKCkpIHJlY292ZXJlZCsrO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGNoYXJ0IGRhdGFcbiAgICAgICAgICB1cGRhdGVDaGFydERhdGEoaW5kZXgsIGhlYWx0aHksIGluZmVjdGVkLCByZWNvdmVyZWQsIGN1cnJlbnREYXkpO1xuXG4gICAgICAgICAgLy8gSW5jcmVtZW50IGN1cnJlbnQgZGF5XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnNpbXVsYXRpb24sXG4gICAgICAgICAgICBjdXJyZW50RGF5OiBjdXJyZW50RGF5ICsgMSxcbiAgICAgICAgICAgIHBlb3BsZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LCAxMDAwKTsgLy8gUnVuIGV2ZXJ5IHNlY29uZCBmb3IgdGhlIHNha2Ugb2Ygc2ltdWxhdGlvblxuXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9LCBbc2ltdWxhdGlvbnNdKTtcblxuICAvLyBGdW5jdGlvbiB0byBoYW5kbGUgdXBkYXRpbmcgVVJMIHBhcmFtZXRlcnNcbiAgY29uc3QgdXBkYXRlVXJsUGFyYW1zID0gKG5ld1BhcmFtczogYW55KSA9PiB7XG4gICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgT2JqZWN0LmVudHJpZXMobmV3UGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcXVlcnkuc2V0KGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcm91dGVyLnB1c2goYD8ke3F1ZXJ5LnRvU3RyaW5nKCl9YCk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLCBnYXA6IFwiMjBweFwiLCBwYWRkaW5nOiBcIjIwcHhcIiB9fT5cbiAgICAgIHsvKiBQb3BvdmVyIEJ1dHRvbiBTZWN0aW9uICovfVxuICAgICAgPGRpdiBzdHlsZT17eyBhbGlnblNlbGY6IFwiY2VudGVyXCIsIG1hcmdpblRvcDogXCIyMHB4XCIgfX0+XG4gICAgICAgIDxTaW11bGF0aW9uQ29udHJvbHNQb3BcbiAgICAgICAgICBhZGRTaW11bGF0aW9uPXthZGRTaW11bGF0aW9ufVxuICAgICAgICAgIHVwZGF0ZVVybFBhcmFtcz17dXBkYXRlVXJsUGFyYW1zfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBMaXN0IG9mIFNpbXVsYXRpb25zICovfVxuICAgICAge3NpbXVsYXRpb25zLm1hcCgoc2ltdWxhdGlvbiwgaW5kZXgpID0+IChcbiAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBzdHlsZT17eyBkaXNwbGF5OiBcImZsZXhcIiwgZ2FwOiBcIjIwcHhcIiwgbWFyZ2luQm90dG9tOiBcIjQwcHhcIiB9fT5cbiAgICAgICAgICB7LyogTGVmdCBTZWN0aW9uOiBDb250cm9scyBhbmQgQ2FudmFzICovfVxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICBnYXA6IFwiMjBweFwiLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8U2ltdWxhdGlvbkNvbnRyb2xzIHsuLi5zaW11bGF0aW9uLnBhcmFtc30gc3BlZWQ9ezF9IGhhbmRsZVNwZWVkQ2hhbmdlPXsoKSA9PiB7fX0gLz5cbiAgICAgICAgICAgIDxQb3B1bGF0aW9uQ2FudmFzXG4gICAgICAgICAgICAgIHBlb3BsZT17c2ltdWxhdGlvbi5wZW9wbGV9XG4gICAgICAgICAgICAgIHZhY2NpbmVFZmZpY2FjeT17c2ltdWxhdGlvbi5wYXJhbXMudmFjY2luZUVmZmljYWN5fVxuICAgICAgICAgICAgICBpbmZlY3Rpb25Qcm9iYWJpbGl0eT17c2ltdWxhdGlvbi5wYXJhbXMuaW5mZWN0aW9uUHJvYmFiaWxpdHl9XG4gICAgICAgICAgICAgIHZhY2NpbmF0ZWRSZWNvdmVyeVJhdGU9e3NpbXVsYXRpb24ucGFyYW1zLnZhY2NpbmF0ZWRSZWNvdmVyeVJhdGV9XG4gICAgICAgICAgICAgIHVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZT17c2ltdWxhdGlvbi5wYXJhbXMudW52YWNjaW5hdGVkUmVjb3ZlcnlSYXRlfVxuICAgICAgICAgICAgICB0b3RhbERheXM9e3NpbXVsYXRpb24ucGFyYW1zLnRvdGFsRGF5c31cbiAgICAgICAgICAgICAgdXBkYXRlQ2hhcnREYXRhPXsoaGVhbHRoeSwgaW5mZWN0ZWQsIHJlY292ZXJlZCwgZnJhbWUpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDaGFydERhdGEoaW5kZXgsIGhlYWx0aHksIGluZmVjdGVkLCByZWNvdmVyZWQsIGZyYW1lKTtcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7LyogUmlnaHQgU2VjdGlvbjogU3RhdHVzIENoYXJ0ICovfVxuICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZmxleDogMSB9fT5cbiAgICAgICAgICAgIDxTdGF0dXNDaGFydCBjaGFydERhdGE9e3NpbXVsYXRpb24uY2hhcnREYXRhfSAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkpfVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5cbiJdLCJuYW1lcyI6WyJ1c2VTZWFyY2hQYXJhbXMiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIlNpbXVsYXRpb25Db250cm9scyIsIlBvcHVsYXRpb25DYW52YXMiLCJTdGF0dXNDaGFydCIsIlNpbXVsYXRpb25Db250cm9sc1BvcCIsIlBlcnNvbiIsIlNpbXVsYXRpb24iLCJzZWFyY2hQYXJhbXMiLCJyb3V0ZXIiLCJzaW11bGF0aW9ucyIsInNldFNpbXVsYXRpb25zIiwiZ2V0U2ltdWxhdGlvblBhcmFtcyIsInZhY2NpbmVFZmZpY2FjeSIsInBhcnNlRmxvYXQiLCJnZXQiLCJwb3B1bGF0aW9uVmFjY2luYXRlZCIsImluZmVjdGlvblByb2JhYmlsaXR5IiwidmFjY2luYXRlZFJlY292ZXJ5UmF0ZSIsInVudmFjY2luYXRlZFJlY292ZXJ5UmF0ZSIsInBlYWtJbmZlY3Rpb25EYXkiLCJwYXJzZUludCIsInRvdGFsRGF5cyIsInBvcHVsYXRpb25TaXplIiwiYWRkU2ltdWxhdGlvbiIsInBhcmFtcyIsIm5ld1Blb3BsZSIsImkiLCJ4IiwiTWF0aCIsInJhbmRvbSIsInkiLCJ2YWNjaW5hdGVkIiwicHVzaCIsImluaXRpYWxDaGFydERhdGEiLCJsYWJlbHMiLCJkYXRhc2V0cyIsImxhYmVsIiwiZGF0YSIsImJvcmRlckNvbG9yIiwiZmlsbCIsInByZXZTaW11bGF0aW9ucyIsInBlb3BsZSIsImNoYXJ0RGF0YSIsImN1cnJlbnREYXkiLCJ1cGRhdGVDaGFydERhdGEiLCJzaW11bGF0aW9uSW5kZXgiLCJoZWFsdGh5IiwiaW5mZWN0ZWQiLCJyZWNvdmVyZWQiLCJmcmFtZSIsInVwZGF0ZWRTaW11bGF0aW9ucyIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJtYXAiLCJzaW11bGF0aW9uIiwiaW5kZXgiLCJmb3JFYWNoIiwicGVyc29uIiwidXBkYXRlU3RhdHVzIiwiaXNIZWFsdGh5IiwiaXNJbmZlY3RlZCIsImlzUmVjb3ZlcmVkIiwiY2xlYXJJbnRlcnZhbCIsInVwZGF0ZVVybFBhcmFtcyIsIm5ld1BhcmFtcyIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiZW50cmllcyIsImtleSIsInZhbHVlIiwic2V0IiwidG9TdHJpbmciLCJkaXYiLCJzdHlsZSIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiZ2FwIiwicGFkZGluZyIsImFsaWduU2VsZiIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsImZsZXgiLCJzcGVlZCIsImhhbmRsZVNwZWVkQ2hhbmdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/simulation/page.tsx\n"));

/***/ })

});